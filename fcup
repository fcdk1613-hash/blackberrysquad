#!/usr/bin/env python3
# fcup - squad tournament bot (aiogram 3.x)

import asyncio
import logging
import sqlite3
from datetime import date, timedelta

from aiogram import Bot, Dispatcher, F, types
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import Command
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton,
    InlineKeyboardMarkup, InlineKeyboardButton
)
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State

# ---------------- CONFIG ----------------
API_TOKEN = "8392821328:AAHHINFxwpSZKGRcv0vQXogGc-pnXcAZspI"

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --------------- DB ---------------------
conn = sqlite3.connect("tournament.db", check_same_thread=False)
cursor = conn.cursor()

cursor.execute("""
CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    phone TEXT,
    role TEXT,
    team_name TEXT
)
""")

cursor.execute("""
CREATE TABLE IF NOT EXISTS match_requests (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team_id INTEGER,
    date TEXT,
    time TEXT
)
""")

cursor.execute("""
CREATE TABLE IF NOT EXISTS matches (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team1_id INTEGER,
    team2_id INTEGER,
    date TEXT,
    time TEXT,
    result TEXT,
    judge_id INTEGER
)
""")
conn.commit()

# ------------- FSM states ---------------
class RegStates(StatesGroup):
    choosing_role = State()
    waiting_for_phone = State()
    waiting_for_team_name = State()

class ScheduleStates(StatesGroup):
    choosing_date = State()
    choosing_time = State()

class JudgeStates(StatesGroup):
    choosing_match = State()
    entering_result = State()

# ------------- Bot init -----------------
bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher(storage=MemoryStorage())

# ------------- Keyboards ----------------
role_kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä"), KeyboardButton(text="‚öñÔ∏è –Ø - —Å—É–¥—å—è")]
    ],
    resize_keyboard=True
)

contact_kb = ReplyKeyboardMarkup(
    keyboard=[[KeyboardButton(text="üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º", request_contact=True)]],
    resize_keyboard=True,
    one_time_keyboard=True
)

commander_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É")],
        [KeyboardButton(text="üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")],
        [KeyboardButton(text="üìú –ú–æ–∏ –º–∞—Ç—á–∏")]
    ],
    resize_keyboard=True
)

judge_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìù –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç")],
        [KeyboardButton(text="üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É")],
        [KeyboardButton(text="üìú –í—Å–µ –º–∞—Ç—á–∏")]
    ],
    resize_keyboard=True
)

back_kb = ReplyKeyboardMarkup(
    keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]],
    resize_keyboard=True
)

# ------------- Helpers ------------------
def dates_next_week():
    today = date.today()
    return [(today + timedelta(days=i)).isoformat() for i in range(7)]

def send_safe(user_id: int, text: str):
    async def _send():
        try:
            await bot.send_message(user_id, text)
        except Exception as e:
            logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ %s: %s", user_id, e)
    asyncio.create_task(_send())

def has_match(team_id: int, date_iso: str, time_val: str) -> bool:
    cursor.execute("SELECT 1 FROM matches WHERE (team1_id=? OR team2_id=?) AND date=? AND time=?",
                   (team_id, team_id, date_iso, time_val))
    return cursor.fetchone() is not None

# ------------- Handlers -----------------
@dp.message(Command("start"))
async def cmd_start(message: types.Message, state: FSMContext):
    cursor.execute("SELECT role, team_name FROM users WHERE user_id = ?", (message.from_user.id,))
    r = cursor.fetchone()
    if r:
        role = r[0]
        if role == "commander":
            await message.answer("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä.", reply_markup=commander_menu)
        else:
            await message.answer("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è.", reply_markup=judge_menu)
        return

    await message.answer("–ü—Ä–∏–≤–µ—Ç! –í—ã–±–µ—Ä–∏ —Ä–æ–ª—å:", reply_markup=role_kb)
    await state.set_state(RegStates.choosing_role)

# --- –í—ã–±–æ—Ä —Ä–æ–ª–∏ ---
@dp.message(RegStates.choosing_role, F.text.in_(["üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä", "‚öñÔ∏è –Ø - —Å—É–¥—å—è"]))
async def choose_role(message: types.Message, state: FSMContext):
    role = "commander" if message.text == "üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä" else "judge"
    await state.update_data(chosen_role=role)
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞:", reply_markup=contact_kb)
    await state.set_state(RegStates.waiting_for_phone)

# --- –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–∞–∫—Ç–∞ ---
@dp.message(RegStates.waiting_for_phone, F.content_type == types.ContentType.CONTACT)
async def got_contact(message: types.Message, state: FSMContext):
    phone = message.contact.phone_number
    data = await state.get_data()
    role = data.get("chosen_role")
    user_id = message.from_user.id

    cursor.execute("INSERT OR REPLACE INTO users (user_id, phone, role) VALUES (?, ?, ?)", (user_id, phone, role))
    conn.commit()

    if role == "commander":
        await message.answer("–û—Ç–ª–∏—á–Ω–æ. –í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã (–æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ):", reply_markup=types.ReplyKeyboardRemove())
        await state.set_state(RegStates.waiting_for_team_name)
    else:
        await message.answer("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è ‚úÖ", reply_markup=judge_menu)
        await state.clear()

# --- –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã ---
@dp.message(RegStates.waiting_for_team_name, F.text)
async def got_team_name(message: types.Message, state: FSMContext):
    team_name = message.text.strip()
    if not team_name:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ –µ—â—ë —Ä–∞–∑.")
        return

    user_id = message.from_user.id
    cursor.execute("UPDATE users SET team_name = ? WHERE user_id = ?", (team_name, user_id))
    conn.commit()

    await message.answer(f"–ö–æ–º–∞–Ω–¥–∞ <b>{team_name}</b> –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞ ‚úÖ", reply_markup=commander_menu)
    await state.clear()

# --- –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É (–∫–æ–º–∞–Ω–¥–∏—Ä) ---
@dp.message(F.text == "üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É")
async def commander_schedule_game(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    cursor.execute("SELECT role FROM users WHERE user_id=?", (user_id,))
    r = cursor.fetchone()
    if not r or r[0] != "commander":
        await message.answer("–¢–æ–ª—å–∫–æ –¥–ª—è –∫–æ–º–∞–Ω–¥–∏—Ä–æ–≤.")
        return

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=d, callback_data=f"date:{d}")] for d in dates_next_week()
    ])
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É:", reply_markup=kb)
    await state.set_state(ScheduleStates.choosing_date)

@dp.callback_query(ScheduleStates.choosing_date, F.data.startswith("date:"))
async def commander_choose_date(cb: types.CallbackQuery, state: FSMContext):
    date_iso = cb.data.split(":", 1)[1]
    await state.update_data(chosen_date=date_iso)

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t, callback_data=f"time:{t}")]
        for t in ["19:00", "20:00", "21:00"]
    ])
    await cb.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è:", reply_markup=kb)
    await cb.answer()
    await state.set_state(ScheduleStates.choosing_time)

@dp.callback_query(ScheduleStates.choosing_time, F.data.startswith("time:"))
async def commander_choose_time(cb: types.CallbackQuery, state: FSMContext):
    time_val = cb.data.split(":", 1)[1]
    data = await state.get_data()
    date_iso = data["chosen_date"]

    user_id = cb.from_user.id
    cursor.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
    row = cursor.fetchone()
    if not row:
        await cb.message.answer("–û—à–∏–±–∫–∞: –∫–æ–º–∞–Ω–¥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        return
    team_name = row[0]

    if has_match(user_id, date_iso, time_val):
        await cb.message.answer("–£ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã —É–∂–µ –Ω–∞–∑–Ω–∞—á–µ–Ω –º–∞—Ç—á –≤ —ç—Ç–æ –≤—Ä–µ–º—è!")
        await cb.answer()
        await state.clear()
        return

    cursor.execute("SELECT id, team_id FROM match_requests WHERE date=? AND time=? AND team_id!=?",
                   (date_iso, time_val, user_id))
    opponent_req = cursor.fetchone()

    if opponent_req:
        opp_req_id, opp_team_id = opponent_req
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (opp_team_id,))
        opp_name = cursor.fetchone()[0]

        cursor.execute("INSERT INTO matches (team1_id, team2_id, date, time) VALUES (?, ?, ?, ?)",
                       (user_id, opp_team_id, date_iso, time_val))
        conn.commit()

        cursor.execute("DELETE FROM match_requests WHERE id=?", (opp_req_id,))
        conn.commit()

        await cb.message.answer(f"–ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω: {team_name} vs {opp_name} ‚Äî {date_iso} {time_val}")

        send_safe(opp_team_id, f"–ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω: {opp_name} vs {team_name} ‚Äî {date_iso} {time_val}")
    else:
        cursor.execute("INSERT INTO match_requests (team_id, date, time) VALUES (?, ?, ?)",
                       (user_id, date_iso, time_val))
        conn.commit()
        await cb.message.answer(f"–ó–∞–ø—Ä–æ—Å –Ω–∞ –º–∞—Ç—á —Å–æ–∑–¥–∞–Ω: {team_name}, {date_iso} {time_val}")

    await cb.answer()
    await state.clear()

# --- –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ ---
@dp.message(F.text == "üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
async def my_schedule(message: types.Message):
    user_id = message.from_user.id
    cursor.execute("SELECT date, time FROM match_requests WHERE team_id=?", (user_id,))
    rows = cursor.fetchall()
    if not rows:
        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –æ–∂–∏–¥–∞—é—â–∏—Ö –∑–∞—è–≤–æ–∫.")
        return
    txt = "–í–∞—à–∏ –∑–∞—è–≤–∫–∏:\n" + "\n".join([f"{d} {t}" for d, t in rows])
    await message.answer(txt)

# --- –ú–æ–∏ –º–∞—Ç—á–∏ ---
@dp.message(F.text == "üìú –ú–æ–∏ –º–∞—Ç—á–∏")
async def my_matches(message: types.Message):
    user_id = message.from_user.id
    cursor.execute("SELECT id, team1_id, team2_id, date, time, result FROM matches WHERE team1_id=? OR team2_id=?",
                   (user_id, user_id))
    rows = cursor.fetchall()
    if not rows:
        await message.answer("–ú–∞—Ç—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
        return
    txt = "–í–∞—à–∏ –º–∞—Ç—á–∏:\n"
    for mid, t1, t2, d, tm, res in rows:
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        tn1 = cursor.fetchone()[0]
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        tn2 = cursor.fetchone()[0]
        txt += f"ID {mid}: {d} {tm} {tn1} vs {tn2} ‚Äî {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –Ω–µ—Ç'}\n"
    await message.answer(txt)

# --- –°—É–¥—å—è: –¥–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç ---
@dp.message(F.text == "üìù –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç")
async def judge_add_result(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    cursor.execute("SELECT role FROM users WHERE user_id=?", (user_id,))
    r = cursor.fetchone()
    if not r or r[0] != "judge":
        await message.answer("–¢–æ–ª—å–∫–æ –¥–ª—è —Å—É–¥–µ–π.")
        return

    cursor.execute("SELECT id, team1_id, team2_id, date, time FROM matches WHERE result IS NULL")
    rows = cursor.fetchall()
    if not rows:
        await message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.")
        return

    buttons = []
    for mid, t1, t2, d, tm in rows:
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        tn1 = cursor.fetchone()[0]
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        tn2 = cursor.fetchone()[0]
        buttons.append([InlineKeyboardButton(text=f"ID {mid}: {d} {tm} {tn1} vs {tn2}", callback_data=f"choose_match:{mid}")])

    kb = InlineKeyboardMarkup(inline_keyboard=buttons)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞:", reply_markup=kb)
    await state.set_state(JudgeStates.choosing_match)

@dp.callback_query(JudgeStates.choosing_match, F.data.startswith("choose_match:"))
async def judge_choose_match(cb: types.CallbackQuery, state: FSMContext):
    _, mid_str = cb.data.split(":", 1)
    await state.update_data(match_id=int(mid_str))
    await cb.message.answer(f"–í–≤–µ–¥–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –º–∞—Ç—á–∞ ID {mid_str} (–Ω–∞–ø—Ä–∏–º–µ—Ä: Team1 1:0 Team2)")
    await cb.answer()
    await state.set_state(JudgeStates.entering_result)

@dp.message(JudgeStates.entering_result, F.text)
async def save_result(message: types.Message, state: FSMContext):
    data = await state.get_data()
    match_id = data.get("match_id")
    result = message.text.strip()
    if not match_id:
        await message.answer("–û—à–∏–±–∫–∞: –º–∞—Ç—á –Ω–µ –≤—ã–±—Ä–∞–Ω.")
        return

    cursor.execute("UPDATE matches SET result=?, judge_id=? WHERE id=?", (result, message.from_user.id, match_id))
    conn.commit()
    await message.answer(f"–†–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –º–∞—Ç—á–∞ {match_id} —Å–æ—Ö—Ä–∞–Ω—ë–Ω ‚úÖ")
    await state.clear()

# --- –°—É–¥—å—è: –≤—Å–µ –º–∞—Ç—á–∏ ---
@dp.message(F.text == "üìú –í—Å–µ –º–∞—Ç—á–∏")
async def all_matches(message: types.Message):
    cursor.execute("SELECT id, team1_id, team2_id, date, time, result FROM matches")
    rows = cursor.fetchall()
    if not rows:
        await message.answer("–ú–∞—Ç—á–µ–π –Ω–µ—Ç.")
        return
    txt = "–í—Å–µ –º–∞—Ç—á–∏:\n"
    for mid, t1, t2, d, tm, res in rows:
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        tn1 = cursor.fetchone()[0]
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        tn2 = cursor.fetchone()[0]
        txt += f"ID {mid}: {d} {tm} {tn1} vs {tn2} ‚Äî {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –Ω–µ—Ç'}\n"
    await message.answer(txt)

# --- –°—É–¥—å—è: —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É ---
@dp.message(F.text == "üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É")
async def results_by_date(message: types.Message):
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=d, callback_data=f"resdate:{d}")] for d in dates_next_week()
    ])
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É:", reply_markup=kb)

@dp.callback_query(F.data.startswith("resdate:"))
async def show_results_by_date(cb: types.CallbackQuery):
    date_iso = cb.data.split(":", 1)[1]
    cursor.execute("SELECT id, team1_id, team2_id, time, result FROM matches WHERE date=?", (date_iso,))
    rows = cursor.fetchall()
    if not rows:
        await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –Ω–∞ —ç—Ç—É –¥–∞—Ç—É.")
        await cb.answer()
        return
    txt = f"–ú–∞—Ç—á–∏ {date_iso}:\n"
    for mid, t1, t2, tm, res in rows:
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        tn1 = cursor.fetchone()[0]
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        tn2 = cursor.fetchone()[0]
        txt += f"ID {mid}: {tm} {tn1} vs {tn2} ‚Äî {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –Ω–µ—Ç'}\n"
    await cb.message.answer(txt)
    await cb.answer()

# ------------- –ó–∞–ø—É—Å–∫ -------------
async def main():
    logger.info("Deleting webhook (if any) and starting polling")
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
