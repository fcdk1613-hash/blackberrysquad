#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
–ü–æ–ª–Ω—ã–π —Ä–∞–±–æ—á–∏–π –∫–æ–¥ –±–æ—Ç–∞ —Ç—É—Ä–Ω–∏—Ä–∞ Squad (aiogram 3.x).
(–ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –∞–¥–º–∏–Ω–∞–º–∏, –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø–æ–¥–±–æ—Ä–æ–º —Å–µ—Ä–≤–µ—Ä–æ–≤ –∏ –∫–∞—Ä—Ç,
–ø–µ—Ä–µ–Ω–æ—Å–æ–º –º–∞—Ç—á–µ–π –≤ history –ø–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É –∏ –ø—Ä.)
–ò–∑–º–µ–Ω–µ–Ω–∏–µ: –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ä–∞–±–æ—á–∏–π —Ö—ç–Ω–¥–ª–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏ –º–∞—Ç—á–µ–π –¥–ª—è —Å—É–¥–µ–π.
"""

import asyncio
import logging
import sqlite3
import random
from datetime import date, timedelta
from typing import Optional, List

from aiogram import Bot, Dispatcher, F, types
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import Command
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove,
    InlineKeyboardMarkup, InlineKeyboardButton
)
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State

# ----------------- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ -----------------
API_TOKEN = "8392821328:AAHHINFxwpSZKGRcv0vQXogGc-pnXcAZspI"   # <-- –≤—Å—Ç–∞–≤—å —Å—é–¥–∞ —Ç–æ–∫–µ–Ω
GROUP_CHAT_ID: Optional[int] = None  # –Ω–∞–ø—Ä–∏–º–µ—Ä -1001234567890 –∏–ª–∏ None

DB_PATH = "tournament.db"

# –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã ‚Äî —É–∫–∞–∂–∏ —Ä–µ–∞–ª—å–Ω—ã–µ ID –∞–¥–º–∏–Ω–æ–≤
ADMIN_IDS: List[int] = [403704696, 1806167653]

# –°–ø–∏—Å–æ–∫ —Å–µ—Ä–≤–µ—Ä–æ–≤ (–ü–µ—Ä–≤—ã–π —Å–µ—Ä–≤–µ—Ä –∏—Å–∫–ª—é—á—ë–Ω)
SERVER_LIST = ["Server 2", "Server 3", "Server 4"]

# –°–ø–∏—Å–æ–∫ –∫–∞—Ä—Ç
MAP_LIST = ["Narva", "Mutaha", "Harju", "Fallujah", "BlackCoast", "Sanxian"]

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --------------- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î ---------------
def init_db():
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()

    # users: –¥–æ–±–∞–≤–ª—è–µ–º approved –ø—Ä–∏ –º–∏–≥—Ä–∞—Ü–∏–∏ (—Å–º. ensure_users_approved_column)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            phone TEXT,
            role TEXT,
            team_name TEXT
        )
    """)

    cur.execute("""
        CREATE TABLE IF NOT EXISTS match_requests (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team_id INTEGER,
            date TEXT,
            time TEXT
        )
    """)

    cur.execute("""
        CREATE TABLE IF NOT EXISTS matches (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team1_id INTEGER,
            team2_id INTEGER,
            date TEXT,
            time TEXT,
            result TEXT,
            judge_id INTEGER,
            server TEXT,
            map TEXT
        )
    """)

    cur.execute("""
        CREATE TABLE IF NOT EXISTS pending_matches (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team1_id INTEGER,
            team2_id INTEGER,
            date TEXT,
            time TEXT,
            server TEXT,
            map_choice_team1 TEXT,
            map_choice_team2 TEXT
        )
    """)

    cur.execute("""
        CREATE TABLE IF NOT EXISTS history (
            id INTEGER PRIMARY KEY,
            team1_id INTEGER,
            team2_id INTEGER,
            date TEXT,
            time TEXT,
            result TEXT,
            judge_id INTEGER,
            server TEXT,
            map TEXT
        )
    """)

    conn.commit()
    conn.close()

def ensure_columns():
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    cur.execute("PRAGMA table_info(matches)")
    cols = [r[1] for r in cur.fetchall()]
    if "server" not in cols:
        try:
            cur.execute("ALTER TABLE matches ADD COLUMN server TEXT")
            conn.commit()
        except Exception as e:
            logger.debug("ALTER TABLE add server failed: %s", e)
    if "map" not in cols:
        try:
            cur.execute("ALTER TABLE matches ADD COLUMN map TEXT")
            conn.commit()
        except Exception as e:
            logger.debug("ALTER TABLE add map failed: %s", e)
    conn.close()

def ensure_users_approved_column():
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    cur.execute("PRAGMA table_info(users)")
    cols = [r[1] for r in cur.fetchall()]
    if "approved" not in cols:
        try:
            cur.execute("ALTER TABLE users ADD COLUMN approved INTEGER DEFAULT 0")
            conn.commit()
        except Exception as e:
            logger.debug("ALTER TABLE add approved failed: %s", e)
    conn.close()

def ensure_pending_confirmations_table():
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS pending_confirmations (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team1_id INTEGER,
            team2_id INTEGER,
            date TEXT,
            times_csv TEXT,
            choice_team1 TEXT,
            choice_team2 TEXT
        )
    """)
    conn.commit()
    conn.close()

init_db()
ensure_columns()
ensure_users_approved_column()
ensure_pending_confirmations_table()

# --------------- FSM ---------------
class RegStates(StatesGroup):
    choosing_role = State()
    waiting_for_contact = State()
    waiting_for_team_name = State()

class ScheduleStates(StatesGroup):
    choosing_date = State()
    choosing_time = State()

class JudgeStates(StatesGroup):
    choosing_match = State()
    entering_result = State()

class DeleteStates(StatesGroup):
    choosing_delete_match = State()

class HistoryStates(StatesGroup):
    choosing_year = State()
    choosing_month = State()
    choosing_day = State()

# --------------- –ë–æ—Ç –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä ---------------
bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher(storage=MemoryStorage())

# --------------- –£—Ç–∏–ª–∏—Ç—ã ---------------
def conn_cursor():
    conn = sqlite3.connect(DB_PATH, check_same_thread=False)
    cur = conn.cursor()
    return conn, cur

def dates_next_week_iso() -> List[str]:
    today = date.today()
    return [(today + timedelta(days=i)).isoformat() for i in range(7)]

async def send_safe(user_id: int, text: str):
    try:
        await bot.send_message(user_id, text)
    except Exception as e:
        logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ª–∏—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ %s: %s", user_id, e)

def user_team_name(user_id: int) -> Optional[str]:
    conn, cur = conn_cursor()
    cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return r[0] if r and r[0] else None

def is_commander(user_id: int) -> bool:
    conn, cur = conn_cursor()
    cur.execute("SELECT role, approved FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return bool(r and r[0] == "commander" and r[1] == 1)

def is_judge(user_id: int) -> bool:
    conn, cur = conn_cursor()
    cur.execute("SELECT role, approved FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return bool(r and r[0] == "judge" and r[1] == 1)

def is_admin(user_id: int) -> bool:
    return user_id in ADMIN_IDS

def has_match(team_id: int, date_iso: str, time_val: str) -> bool:
    conn, cur = conn_cursor()
    cur.execute("""
        SELECT 1 FROM matches
        WHERE (team1_id=? OR team2_id=?) AND date=? AND time=?
    """, (team_id, team_id, date_iso, time_val))
    r = cur.fetchone()
    conn.close()
    return r is not None

def remove_request(team_id: int, date_iso: str, time_val: str):
    conn, cur = conn_cursor()
    cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (team_id, date_iso, time_val))
    conn.commit()
    conn.close()

def get_used_servers(date_iso: str, time_val: str) -> List[str]:
    conn, cur = conn_cursor()
    cur.execute("SELECT server FROM matches WHERE date=? AND time=? AND server IS NOT NULL", (date_iso, time_val))
    rows = cur.fetchall()
    conn.close()
    return [r[0] for r in rows if r and r[0]]

def pick_free_server(date_iso: str, time_val: str) -> Optional[str]:
    used = set(get_used_servers(date_iso, time_val))
    for s in SERVER_LIST:
        if s not in used:
            return s
    return None

# --------------- –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---------------
role_kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä"), KeyboardButton(text="‚öñÔ∏è –Ø - —Å—É–¥—å—è")]
    ],
    resize_keyboard=True
)

contact_kb = ReplyKeyboardMarkup(
    keyboard=[[KeyboardButton(text="üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º", request_contact=True)]],
    resize_keyboard=True,
    one_time_keyboard=True
)

commander_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É"), KeyboardButton(text="üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")],
        [KeyboardButton(text="üìú –ú–æ–∏ –º–∞—Ç—á–∏"), KeyboardButton(text="üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π")]
    ],
    resize_keyboard=True
)

judge_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìù –í–Ω–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç"), KeyboardButton(text="üìú –í—Å–µ –º–∞—Ç—á–∏")],
        [KeyboardButton(text="üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π"), KeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –º–∞—Ç—á")]
    ],
    resize_keyboard=True
)

back_kb = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="üîô –ù–∞–∑–∞–¥")]], resize_keyboard=True)

# --------------- –•—ç–Ω–¥–ª–µ—Ä—ã ---------------

@dp.message(Command("start"))
async def cmd_start(message: types.Message, state: FSMContext):
    conn, cur = conn_cursor()
    cur.execute("SELECT role, team_name, COALESCE(approved,0) FROM users WHERE user_id=?", (message.from_user.id,))
    r = cur.fetchone()
    conn.close()

    if r:
        role, team_name, approved = r
        if not approved:
            await message.answer("‚è≥ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ–∂–∏–¥–∞–µ—Ç –æ–¥–æ–±—Ä–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞. –ü–æ–¥–æ–∂–¥–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞.")
            return
        if role == "commander":
            await message.answer("–í—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä.", reply_markup=commander_menu)
        elif role == "judge":
            await message.answer("–í—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è.", reply_markup=judge_menu)
        else:
            await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å:", reply_markup=role_kb)
    else:
        await message.answer("–ü—Ä–∏–≤–µ—Ç! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å:", reply_markup=role_kb)
        await state.set_state(RegStates.choosing_role)

# ---- –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Ä–æ–ª–∏ –∏ —Ç–µ–ª–µ—Ñ–æ–Ω (–æ–∂–∏–¥–∞–µ—Ç –æ–¥–æ–±—Ä–µ–Ω–∏—è) ----
@dp.message(RegStates.choosing_role, F.text.in_(["üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä", "‚öñÔ∏è –Ø - —Å—É–¥—å—è"]))
async def choose_role(message: types.Message, state: FSMContext):
    role = "commander" if message.text == "üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä" else "judge"
    await state.update_data(chosen_role=role)
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–∫–Ω–æ–ø–∫–∞):", reply_markup=contact_kb)
    await state.set_state(RegStates.waiting_for_contact)

@dp.message(RegStates.waiting_for_contact, F.content_type == types.ContentType.CONTACT)
async def got_contact(message: types.Message, state: FSMContext):
    contact = message.contact
    phone = contact.phone_number if contact else None
    data = await state.get_data()
    role = data.get("chosen_role")
    user_id = message.from_user.id

    conn, cur = conn_cursor()
    cur.execute("""
        INSERT OR REPLACE INTO users (user_id, phone, role, team_name, approved)
        VALUES (?, ?, ?, COALESCE((SELECT team_name FROM users WHERE user_id=?), NULL), 0)
    """, (user_id, phone, role, user_id))
    conn.commit()
    conn.close()

    if role == "commander":
        await message.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã (–æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ):", reply_markup=ReplyKeyboardRemove())
        await state.set_state(RegStates.waiting_for_team_name)
    else:
        await message.answer("‚è≥ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –∫–∞–∫ —Å—É–¥—å–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        for aid in ADMIN_IDS:
            try:
                await send_safe(aid, f"üö® –ó–∞–ø—Ä–æ—Å –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é —Å—É–¥—å–∏\nID: {user_id}\n–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /accept {user_id} –∏–ª–∏ /decline {user_id}")
            except Exception:
                logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø–æ–≤–µ—Å—Ç–∏—Ç—å –∞–¥–º–∏–Ω–∞ %s –æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Å—É–¥—å–∏ %s", aid, user_id)
        await state.clear()

@dp.message(RegStates.waiting_for_team_name, F.text)
async def got_team_name(message: types.Message, state: FSMContext):
    team_name = message.text.strip()
    if not team_name:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ –µ—â—ë —Ä–∞–∑:")
        return

    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("UPDATE users SET team_name=?, approved=0 WHERE user_id=?", (team_name, user_id))
    conn.commit()
    cur.execute("SELECT phone FROM users WHERE user_id=?", (user_id,))
    phone_row = cur.fetchone()
    phone = phone_row[0] if phone_row and phone_row[0] else "‚Äî"
    conn.close()

    await message.answer(f"‚è≥ –ó–∞—è–≤–∫–∞ –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∫–æ–º–∞–Ω–¥—ã <b>{team_name}</b> –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
    for aid in ADMIN_IDS:
        try:
            await send_safe(aid, f"üö® –ó–∞–ø—Ä–æ—Å –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∫–æ–º–∞–Ω–¥—ã\nID: {user_id}\n–ö–æ–º–∞–Ω–¥–∞: {team_name}\n–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n\n–î–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è: /accept {user_id}\n–î–ª—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è: /decline {user_id}")
        except Exception:
            logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø–æ–≤–µ—Å—Ç–∏—Ç—å –∞–¥–º–∏–Ω–∞ %s –æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∫–æ–º–∞–Ω–¥—ã %s", aid, team_name)
    await state.clear()

# ---- –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Ç—á–∞: –¥–∞—Ç–∞ -> –≤—Ä–µ–º—è -> –ª–æ–≥–∏–∫–∞ –ø–æ–¥–±–æ—Ä–∞ ----
@dp.message(F.text == "üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É")
async def start_schedule(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if not is_commander(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ –∫–æ–º–∞–Ω–¥–∏—Ä—ã –º–æ–≥—É—Ç –Ω–∞–∑–Ω–∞—á–∞—Ç—å –∏–≥—Ä—ã. –°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –∏ –¥–æ–∂–¥–∏—Ç–µ—Å—å –æ–¥–æ–±—Ä–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
        return
    tname = user_team_name(user_id)
    if not tname:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã (—á–µ—Ä–µ–∑ /start).")
        return

    dates = dates_next_week_iso()
    inline = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=d, callback_data=f"slot_date:{d}")] for d in dates
    ])
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π):", reply_markup=inline)
    await state.set_state(ScheduleStates.choosing_date)

@dp.callback_query(F.data.startswith("slot_date:"))
async def on_date_chosen(cb: types.CallbackQuery, state: FSMContext):
    date_iso = cb.data.split(":", 1)[1]
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="19:00", callback_data=f"slot_time:{date_iso}|19:00")],
        [InlineKeyboardButton(text="20:00", callback_data=f"slot_time:{date_iso}|20:00")],
        [InlineKeyboardButton(text="21:00", callback_data=f"slot_time:{date_iso}|21:00")],
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="slot_back")]
    ])
    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω–∞ –¥–∞—Ç–∞ <b>{date_iso}</b>. –í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è:", reply_markup=kb)
    await cb.answer()
    await state.update_data(chosen_date=date_iso)
    await state.set_state(ScheduleStates.choosing_time)

@dp.callback_query(F.data == "slot_back")
async def slot_back(cb: types.CallbackQuery, state: FSMContext):
    dates = dates_next_week_iso()
    inline = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=d, callback_data=f"slot_date:{d}")] for d in dates
    ])
    await cb.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π):", reply_markup=inline)
    await cb.answer()
    await state.set_state(ScheduleStates.choosing_date)

@dp.callback_query(F.data.startswith("slot_time:"))
async def on_time_chosen(cb: types.CallbackQuery, state: FSMContext):
    payload = cb.data.split(":", 1)[1]
    date_iso, time_val = payload.split("|", 1)
    user_id = cb.from_user.id

    if not is_commander(user_id):
        await cb.message.answer("–¢–æ–ª—å–∫–æ –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ –∫–æ–º–∞–Ω–¥–∏—Ä—ã –º–æ–≥—É—Ç –Ω–∞–∑–Ω–∞—á–∞—Ç—å –∏–≥—Ä—ã.")
        await cb.answer()
        return

    if has_match(user_id, date_iso, time_val):
        await cb.message.answer("‚ùå –£ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã —É–∂–µ –Ω–∞–∑–Ω–∞—á–µ–Ω –º–∞—Ç—á –≤ —ç—Ç–æ—Ç –¥–µ–Ω—å/–≤—Ä–µ–º—è.")
        await cb.answer()
        await state.clear()
        return

    conn, cur = conn_cursor()
    cur.execute("SELECT id FROM match_requests WHERE team_id=? AND date=? AND time=?", (user_id, date_iso, time_val))
    if cur.fetchone():
        conn.close()
        await cb.message.answer("–£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –∑–∞—è–≤–∫–∞ –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç ‚Äî –∂–¥—ë–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.")
        await cb.answer()
        await state.clear()
        return

    cur.execute("INSERT INTO match_requests (team_id, date, time) VALUES (?, ?, ?)", (user_id, date_iso, time_val))
    conn.commit()

    cur.execute("SELECT team_id, time FROM match_requests WHERE date=? AND team_id!=?", (date_iso, user_id))
    other_rows = cur.fetchall()
    others_times = {}
    for tid, t in other_rows:
        others_times.setdefault(tid, set()).add(t)

    cur.execute("SELECT time FROM match_requests WHERE date=? AND team_id=?", (date_iso, user_id))
    my_times = set([r[0] for r in cur.fetchall()])

    matched = False
    for candidate_id, times_set in others_times.items():
        common = sorted(list(my_times.intersection(times_set)))
        if not common:
            continue

        if len(common) == 1:
            chosen_time = common[0]
            free_server = pick_free_server(date_iso, chosen_time)
            if not free_server:
                cur.execute("SELECT team_name FROM users WHERE user_id=?", (candidate_id,))
                t1 = cur.fetchone(); t1_name = t1[0] if t1 and t1[0] else f"ID {candidate_id}"
                cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
                t2 = cur.fetchone(); t2_name = t2[0] if t2 and t2[0] else f"ID {user_id}"
                text = f"‚ö†Ô∏è –ù–∞ {date_iso} {chosen_time} –≤—Å–µ —Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–Ω—è—Ç—ã. –ú–∞—Ç—á –º–µ–∂–¥—É {t1_name} –∏ {t2_name} –ø–æ–∫–∞ –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω ‚Äî –∑–∞—è–≤–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã."
                await send_safe(candidate_id, text)
                await send_safe(user_id, text)
                if GROUP_CHAT_ID:
                    try:
                        await bot.send_message(GROUP_CHAT_ID, f"–ü–æ–ø—ã—Ç–∫–∞ –Ω–∞–∑–Ω–∞—á–∏—Ç—å –º–∞—Ç—á {t1_name} vs {t2_name} –Ω–∞ {date_iso} {chosen_time}, –Ω–æ –≤—Å–µ —Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–Ω—è—Ç—ã.")
                    except Exception:
                        pass
                conn.close()
                await cb.answer()
                await state.clear()
                return

            final_map = random.choice(MAP_LIST)
            cur.execute("INSERT INTO matches (team1_id, team2_id, date, time, server, map) VALUES (?, ?, ?, ?, ?, ?)",
                        (candidate_id, user_id, date_iso, chosen_time, free_server, final_map))
            match_id = cur.lastrowid
            cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (candidate_id, date_iso, chosen_time))
            cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (user_id, date_iso, chosen_time))
            conn.commit()

            cur.execute("SELECT team_name FROM users WHERE user_id=?", (candidate_id,))
            t1 = cur.fetchone(); t1_name = t1[0] if t1 and t1[0] else f"ID {candidate_id}"
            cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
            t2 = cur.fetchone(); t2_name = t2[0] if t2 and t2[0] else f"ID {user_id}"

            text = f"‚öîÔ∏è <b>–ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω</b>!\nID {match_id}\nüìÖ {date_iso} ‚è∞ {chosen_time}\nüèÜ {t1_name} vs {t2_name}\nüåê –°–µ—Ä–≤–µ—Ä: {free_server}\nüó∫ –ö–∞—Ä—Ç–∞: {final_map}"
            await send_safe(candidate_id, text)
            await send_safe(user_id, text)
            if GROUP_CHAT_ID:
                try:
                    await bot.send_message(GROUP_CHAT_ID, text)
                except Exception:
                    pass

            await cb.message.answer(f"–ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω: {t1_name} vs {t2_name} (ID {match_id})")
            await cb.answer()
            conn.close()
            matched = True
            break

        if len(common) > 1:
            times_csv = ",".join(common)
            cur.execute("INSERT INTO pending_confirmations (team1_id, team2_id, date, times_csv, choice_team1, choice_team2) VALUES (?, ?, ?, ?, NULL, NULL)",
                        (candidate_id, user_id, date_iso, times_csv))
            pc_id = cur.lastrowid
            conn.commit()

            buttons = [[InlineKeyboardButton(text=t, callback_data=f"confirm_time:{pc_id}:{t}")] for t in common]
            buttons.append([InlineKeyboardButton(text="‚ùå –û—Ç–∫–∞–∑–∞—Ç—å—Å—è", callback_data=f"confirm_time:{pc_id}:CANCEL")])
            kb = InlineKeyboardMarkup(inline_keyboard=buttons)

            cur.execute("SELECT team_name FROM users WHERE user_id=?", (candidate_id,))
            t1 = cur.fetchone(); t1_name = t1[0] if t1 and t1[0] else f"ID {candidate_id}"
            cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
            t2 = cur.fetchone(); t2_name = t2[0] if t2 and t2[0] else f"ID {user_id}"

            txt = (f"üîî –ù–∞–π–¥–µ–Ω —Å–æ–ø–µ—Ä–Ω–∏–∫: {t1_name} vs {t2_name}\n"
                   f"üìÖ {date_iso}\n"
                   f"–£ –≤–∞—Å –æ–±—â–∏–µ –≤—Ä–µ–º–µ–Ω–∞: {', '.join(common)}\n"
                   f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω–æ –∏–∑ –Ω–∏—Ö (–æ–±–∞ –¥–æ–ª–∂–Ω—ã –≤—ã–±—Ä–∞—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Å–ª–æ—Ç):")
            await send_safe(candidate_id, txt)
            await send_safe(user_id, txt)
            try:
                await bot.send_message(candidate_id, "–í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è:", reply_markup=kb)
            except Exception:
                logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫—É –≤—ã–±–æ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏ –∫–æ–º–∞–Ω–¥–µ %s", candidate_id)
            try:
                await bot.send_message(user_id, "–í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è:", reply_markup=kb)
            except Exception:
                logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫—É –≤—ã–±–æ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏ –∫–æ–º–∞–Ω–¥–µ %s", user_id)

            matched = True
            break

    conn.close()
    if not matched:
        await cb.message.answer(f"‚úÖ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –Ω–∞ {date_iso} {time_val}. –û–∂–∏–¥–∞–µ–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.")
    await cb.answer()
    await state.clear()

# ---- –ü—Ä–æ—Å–º–æ—Ç—Ä –∑–∞—è–≤–æ–∫ / —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è / –º–∞—Ç—á–∏ –¥–ª—è –∫–æ–º–∞–Ω–¥–∏—Ä–æ–≤ ----
@dp.message(F.text == "üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
async def my_requests(message: types.Message):
    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("SELECT date, time FROM match_requests WHERE team_id=?", (user_id,))
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞—è–≤–æ–∫.")
        return
    lines = [f"{d} {t}" for d, t in rows]
    await message.answer("üìÖ –í–∞—à–∏ –∑–∞—è–≤–∫–∏:\n" + "\n".join(lines))

@dp.message(F.text == "üìú –ú–æ–∏ –º–∞—Ç—á–∏")
async def my_matches(message: types.Message):
    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time, result, server, map FROM matches WHERE team1_id=? OR team2_id=?", (user_id, user_id))
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–£ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã –ø–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π.")
        return
    text_lines = []
    conn, cur = conn_cursor()
    for mid, t1, t2, d, tm, res, srv, mp in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        n2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        srv_text = f" | –°–µ—Ä–≤–µ—Ä: {srv}" if srv else ""
        map_text = f" | –ö–∞—Ä—Ç–∞: {mp}" if mp else ""
        text_lines.append(f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2}{srv_text}{map_text} | {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –∑–∞–¥–∞–Ω'}")
    conn.close()
    await message.answer("üìú –í–∞—à–∏ –º–∞—Ç—á–∏:\n" + "\n".join(text_lines))

# ---- –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π –¥–ª—è –∫–æ–º–∞–Ω–¥–∏—Ä–æ–≤ (–≥–æ–¥->–º–µ—Å—è—Ü->–¥–µ–Ω—å) ----
@dp.message(F.text == "üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π")
async def history_start(message: types.Message, state: FSMContext):
    user_id = message.from_user.id

    # –ï—Å–ª–∏ —Å—É–¥—å—è ‚Äî –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –≤ —Å—É–¥–µ–π—Å–∫–∏–π —Ö—ç–Ω–¥–ª–µ—Ä (–¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞), –Ω–æ –¥–æ–±–∞–≤–∏–º –æ—Ç–¥–µ–ª—å–Ω—ã–π —Å—É–¥–µ–π—Å–∫–∏–π —Ö—ç–Ω–¥–ª–µ—Ä –Ω–∏–∂–µ
    if is_judge(user_id):
        # –≤—ã–∑—ã–≤–∞–µ–º —Å—É–¥–µ–π—Å–∫–∏–π —Å—Ç–∞—Ä—Ç —á–µ—Ä–µ–∑ —è–≤–Ω—ã–π —Ö—ç–Ω–¥–ª–µ—Ä (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –Ω–∞–∂–∞—Ç–∏—é —Å—É–¥–µ–π—Å–∫–æ–π –∫–Ω–æ–ø–∫–∏)
        await judge_history_entry(message, state)
        return

    # –∫–æ–º–∞–Ω–¥–∏—Ä—Å–∫–∞—è –ª–æ–≥–∏–∫–∞
    conn, cur = conn_cursor()
    cur.execute("""
        SELECT DISTINCT strftime('%Y', date) as year
        FROM matches
        WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL
        ORDER BY year DESC
    """, (user_id, user_id))
    rows = cur.fetchall()
    conn.close()
    years = [r[0] for r in rows if r and r[0]]
    if not years:
        await message.answer("–ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π –ø—É—Å—Ç–∞.", reply_markup=commander_menu)
        return

    inline = InlineKeyboardMarkup(row_width=2)
    buttons = []
    for y in years:
        buttons.append(InlineKeyboardButton(text=y, callback_data=f"hist_year:{y}"))
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:menu"))
    inline.add(*buttons)

    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–¥:", reply_markup=inline)
    await state.set_state(HistoryStates.choosing_year)

# ---- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏ (–∫–æ–º–∞–Ω–¥–∏—Ä) ----
@dp.callback_query(F.data.startswith("hist_year:"))
async def history_year_chosen(cb: types.CallbackQuery, state: FSMContext):
    year = cb.data.split(":", 1)[1]
    user_id = cb.from_user.id
    await state.update_data(year=year)

    conn, cur = conn_cursor()
    cur.execute("""
        SELECT DISTINCT strftime('%m', date) as month
        FROM matches
        WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL AND strftime('%Y', date)=?
        ORDER BY month
    """, (user_id, user_id, year))
    rows = cur.fetchall()
    conn.close()

    months = [r[0] for r in rows if r and r[0]]
    if not months:
        await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –≤ —ç—Ç–æ–º –≥–æ–¥—É.", reply_markup=commander_menu)
        await cb.answer()
        await state.clear()
        return

    inline = InlineKeyboardMarkup(row_width=3)
    buttons = [InlineKeyboardButton(text=m, callback_data=f"hist_month:{m}") for m in months]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:year"))
    inline.add(*buttons)

    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω –≥–æ–¥ {year}. –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—è—Ü:", reply_markup=inline)
    await cb.answer()
    await state.set_state(HistoryStates.choosing_month)

@dp.callback_query(F.data.startswith("hist_month:"))
async def history_month_chosen(cb: types.CallbackQuery, state: FSMContext):
    month = cb.data.split(":", 1)[1]
    user_id = cb.from_user.id
    await state.update_data(month=month)
    data = await state.get_data()
    year = data.get("year")

    conn, cur = conn_cursor()
    cur.execute("""
        SELECT DISTINCT strftime('%d', date) as day
        FROM matches
        WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL
          AND strftime('%Y', date)=? AND strftime('%m', date)=?
        ORDER BY day
    """, (user_id, user_id, year, month))
    rows = cur.fetchall()
    conn.close()

    days = [r[0] for r in rows if r and r[0]]
    if not days:
        await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –≤ —ç—Ç–æ–º –º–µ—Å—è—Ü–µ.", reply_markup=commander_menu)
        await cb.answer()
        await state.clear()
        return

    inline = InlineKeyboardMarkup(row_width=4)
    buttons = [InlineKeyboardButton(text=d, callback_data=f"hist_day:{d}") for d in days]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:month"))
    inline.add(*buttons)

    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω {year}-{month}. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å:", reply_markup=inline)
    await cb.answer()
    await state.set_state(HistoryStates.choosing_day)

@dp.callback_query(F.data.startswith("hist_day:"))
async def history_day_chosen(cb: types.CallbackQuery, state: FSMContext):
    day = cb.data.split(":", 1)[1]
    data = await state.get_data()
    year = data.get("year")
    month = data.get("month")
    user_id = cb.from_user.id

    y = year
    m = month.zfill(2)
    d = day.zfill(2)
    date_iso = f"{y}-{m}-{d}"

    conn, cur = conn_cursor()
    cur.execute("""
        SELECT id, team1_id, team2_id, time, result, server, map
        FROM matches
        WHERE date=? AND (team1_id=? OR team2_id=?)
        ORDER BY time
    """, (date_iso, user_id, user_id))
    rows = cur.fetchall()
    conn.close()

    if not rows:
        await cb.message.answer(f"–ú–∞—Ç—á–µ–π –∑–∞ {date_iso} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", reply_markup=commander_menu)
        await cb.answer()
        await state.clear()
        return

    lines = []
    for mid, t1, t2, tm, res, srv, mp in rows:
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        name1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        name2 = r2[0] if r2 and r2[0] else (f"ID {t2}" if t2 else "??")
        conn.close()
        srv_text = f" | –°–µ—Ä–≤–µ—Ä: {srv}" if srv else ""
        map_text = f" | –ö–∞—Ä—Ç–∞: {mp}" if mp else ""
        lines.append(f"ID {mid}: {tm} ‚Äî {name1} vs {name2}{srv_text}{map_text} | {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –∑–∞–¥–∞–Ω'}")

    await cb.message.answer(f"üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π –∑–∞ {date_iso}:\n" + "\n".join(lines), reply_markup=commander_menu)
    await cb.answer()
    await state.clear()

@dp.callback_query(F.data.startswith("hist_back:"))
async def history_back(cb: types.CallbackQuery, state: FSMContext):
    payload = cb.data.split(":", 1)[1]
    user_id = cb.from_user.id

    if payload == "menu":
        await cb.message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é –∫–æ–º–∞–Ω–¥–∏—Ä–∞:", reply_markup=commander_menu)
        await cb.answer()
        await state.clear()
        return

    if payload == "year":
        conn, cur = conn_cursor()
        cur.execute("""
            SELECT DISTINCT strftime('%Y', date) as year
            FROM matches
            WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL
            ORDER BY year DESC
        """, (user_id, user_id))
        rows = cur.fetchall()
        conn.close()
        years = [r[0] for r in rows if r and r[0]]
        if not years:
            await cb.message.answer("–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.", reply_markup=commander_menu)
            await cb.answer()
            await state.clear()
            return
        inline = InlineKeyboardMarkup(row_width=2)
        buttons = [InlineKeyboardButton(text=y, callback_data=f"hist_year:{y}") for y in years]
        buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:menu"))
        inline.add(*buttons)
        await cb.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–¥:", reply_markup=inline)
        await cb.answer()
        await state.set_state(HistoryStates.choosing_year)
        return

    if payload == "month":
        data = await state.get_data()
        year = data.get("year")
        if not year:
            await cb.message.answer("–û—à–∏–±–∫–∞: –≥–æ–¥ –Ω–µ –≤—ã–±—Ä–∞–Ω.", reply_markup=commander_menu)
            await cb.answer()
            await state.clear()
            return
        conn, cur = conn_cursor()
        cur.execute("""
            SELECT DISTINCT strftime('%m', date) as month
            FROM matches
            WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL AND strftime('%Y', date)=?
            ORDER BY month
        """, (user_id, user_id, year))
        rows = cur.fetchall()
        conn.close()
        months = [r[0] for r in rows if r and r[0]]
        if not months:
            await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –≤ —ç—Ç–æ–º –≥–æ–¥—É.", reply_markup=commander_menu)
            await cb.answer()
            await state.clear()
            return
        inline = InlineKeyboardMarkup(row_width=3)
        buttons = [InlineKeyboardButton(text=m, callback_data=f"hist_month:{m}") for m in months]
        buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:year"))
        inline.add(*buttons)
        await cb.message.answer(f"–í—ã–±—Ä–∞–Ω –≥–æ–¥ {year}. –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—è—Ü:", reply_markup=inline)
        await cb.answer()
        await state.set_state(HistoryStates.choosing_month)
        return

    await cb.answer()

# ---- –°—É–¥—å—è: –í—Å–µ –º–∞—Ç—á–∏ (–Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–µ) ----
@dp.message(F.text == "üìú –í—Å–µ –º–∞—Ç—á–∏")
async def all_matches(message: types.Message):
    if not is_judge(message.from_user.id):
        await message.answer("–¢–æ–ª—å–∫–æ –¥–ª—è —Å—É–¥–µ–π.")
        return
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time, result, server, map FROM matches ORDER BY date, time")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ü–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π.")
        return
    text_lines = []
    conn, cur = conn_cursor()
    for mid, t1, t2, d, tm, res, srv, mp in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        name1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        name2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        srv_text = f" | –°–µ—Ä–≤–µ—Ä: {srv}" if srv else ""
        map_text = f" | –ö–∞—Ä—Ç–∞: {mp}" if mp else ""
        text_lines.append(f"ID {mid}: {d} {tm}{srv_text}{map_text} ‚Äî {name1} vs {name2} | {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –∑–∞–¥–∞–Ω'}")
    conn.close()
    await message.answer("üìú –í—Å–µ –º–∞—Ç—á–∏:\n" + "\n".join(text_lines))

# ---- –°—É–¥—å—è: –í–Ω–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç ----
@dp.message(F.text == "üìù –í–Ω–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç")
async def judge_choose_match_start(message: types.Message, state: FSMContext):
    if not is_judge(message.from_user.id):
        await message.answer("–¢–æ–ª—å–∫–æ —Å—É–¥—å—è –º–æ–∂–µ—Ç –≤–Ω–æ—Å–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç.")
        return

    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time, server, map FROM matches WHERE result IS NULL ORDER BY date, time")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.")
        return

    inline_buttons = []
    for mid, t1, t2, d, tm, server, map_choice in rows:
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        n2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        conn.close()
        inline_buttons.append([InlineKeyboardButton(text=f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2}", callback_data=f"judge_pick:{mid}")])

    kb = InlineKeyboardMarkup(inline_keyboard=inline_buttons)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á –¥–ª—è –≤–≤–æ–¥–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞:", reply_markup=kb)
    await state.set_state(JudgeStates.choosing_match)

@dp.callback_query(JudgeStates.choosing_match, F.data.startswith("judge_pick:"))
async def judge_pick_match(cb: types.CallbackQuery, state: FSMContext):
    mid = int(cb.data.split(":", 1)[1])
    await state.update_data(chosen_match_id=mid)
    await cb.message.answer(f"–í–≤–µ–¥–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –º–∞—Ç—á–∞ ID {mid} –≤ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ (–ø—Ä–∏–º–µ—Ä: 2-1 –∏–ª–∏ Team1 2:1 Team2):")
    await cb.answer()
    await state.set_state(JudgeStates.entering_result)

@dp.message(JudgeStates.entering_result, F.text)
async def judge_save_result(message: types.Message, state: FSMContext):
    data = await state.get_data()
    mid = data.get("chosen_match_id")
    if not mid:
        await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: –º–∞—Ç—á –Ω–µ –≤—ã–±—Ä–∞–Ω. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏—é.")
        await state.clear()
        return
    result_text = message.text.strip()
    conn, cur = conn_cursor()
    cur.execute("SELECT team1_id, team2_id, date, time, server, map FROM matches WHERE id=?", (mid,))
    row = cur.fetchone()
    if not row:
        await message.answer("–ú–∞—Ç—á –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        conn.close()
        await state.clear()
        return
    team1_id, team2_id, d, tm, server, map_choice = row

    cur.execute(
        "INSERT OR REPLACE INTO history (id, team1_id, team2_id, date, time, result, judge_id, server, map) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
        (mid, team1_id, team2_id, d, tm, result_text, message.from_user.id, server, map_choice)
    )
    cur.execute("DELETE FROM matches WHERE id=?", (mid,))
    conn.commit()
    conn.close()

    await send_safe(team1_id, f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ ID {mid}: {result_text} ({d} {tm}) | –°–µ—Ä–≤–µ—Ä: {server or '‚Äî'} | –ö–∞—Ä—Ç–∞: {map_choice or '‚Äî'}")
    if team2_id:
        await send_safe(team2_id, f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ ID {mid}: {result_text} ({d} {tm}) | –°–µ—Ä–≤–µ—Ä: {server or '‚Äî'} | –ö–∞—Ä—Ç–∞: {map_choice or '‚Äî'}")
    if GROUP_CHAT_ID:
        try:
            await bot.send_message(GROUP_CHAT_ID, f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ ID {mid}: {result_text} ({d} {tm}) | –°–µ—Ä–≤–µ—Ä: {server or '‚Äî'} | –ö–∞—Ä—Ç–∞: {map_choice or '‚Äî'}")
        except Exception as e:
            logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å group notify: %s", e)

    await message.answer(f"‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –º–∞—Ç—á–∞ ID {mid} —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∏ –º–∞—Ç—á –ø–µ—Ä–µ–Ω–µ—Å—ë–Ω –≤ –∏—Å—Ç–æ—Ä–∏—é.")
    await state.clear()

# ---- –°—É–¥—å—è: —É–¥–∞–ª–∏—Ç—å –º–∞—Ç—á ----
@dp.message(F.text == "üóë –£–¥–∞–ª–∏—Ç—å –º–∞—Ç—á")
async def judge_delete_match_start(message: types.Message, state: FSMContext):
    if not is_judge(message.from_user.id):
        await message.answer("–¢–æ–ª—å–∫–æ —Å—É–¥—å—è –º–æ–∂–µ—Ç —É–¥–∞–ª—è—Ç—å –º–∞—Ç—á–∏.")
        return

    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time FROM matches ORDER BY date, time")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return

    inline_buttons = []
    for mid, t1, t2, d, tm in rows:
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        n2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        conn.close()
        inline_buttons.append([InlineKeyboardButton(text=f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2}", callback_data=f"del_match:{mid}")])

    kb = InlineKeyboardMarkup(inline_keyboard=inline_buttons)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=kb)
    await state.set_state(DeleteStates.choosing_delete_match)

@dp.callback_query(DeleteStates.choosing_delete_match, F.data.startswith("del_match:"))
async def judge_confirm_delete(cb: types.CallbackQuery, state: FSMContext):
    mid = int(cb.data.split(":", 1)[1])
    conn, cur = conn_cursor()
    cur.execute("SELECT team1_id, team2_id, date, time, server, map FROM matches WHERE id=?", (mid,))
    row = cur.fetchone()
    if not row:
        await cb.message.answer("–ú–∞—Ç—á –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        conn.close()
        await state.clear()
        await cb.answer()
        return
    t1, t2, d, tm, server, map_choice = row
    cur.execute("DELETE FROM matches WHERE id=?", (mid,))
    try:
        cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (t1, d, tm))
        cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (t2, d, tm))
    except Exception as e:
        logger.info("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞—è–≤–æ–∫: %s", e)
    conn.commit()
    conn.close()

    await cb.message.answer(f"–ú–∞—Ç—á ID {mid} —É–¥–∞–ª—ë–Ω ‚úÖ (–º–∞—Ç—á –∏ –∑–∞—è–≤–∫–∏ —É–¥–∞–ª–µ–Ω—ã)")
    await send_safe(t1, f"‚ùå –ú–∞—Ç—á ID {mid} –±—ã–ª —É–¥–∞–ª—ë–Ω —Å—É–¥—å—ë–π ({d} {tm}). –í–∞—à–∏ –∑–∞—è–≤–∫–∏ –Ω–∞ {d} {tm} —Ç–∞–∫–∂–µ —É–¥–∞–ª–µ–Ω—ã.")
    if t2:
        await send_safe(t2, f"‚ùå –ú–∞—Ç—á ID {mid} –±—ã–ª —É–¥–∞–ª—ë–Ω —Å—É–¥—å—ë–π ({d} {tm}). –í–∞—à–∏ –∑–∞—è–≤–∫–∏ –Ω–∞ {d} {tm} —Ç–∞–∫–∂–µ —É–¥–∞–ª–µ–Ω—ã.")
    if GROUP_CHAT_ID:
        try:
            await bot.send_message(GROUP_CHAT_ID, f"‚ùå –ú–∞—Ç—á ID {mid} –±—ã–ª —É–¥–∞–ª—ë–Ω —Å—É–¥—å—ë–π ({d} {tm}).")
        except Exception:
            pass

    await state.clear()
    await cb.answer()

# --------------- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ "üîô –ù–∞–∑–∞–¥" ---------------
@dp.message(F.text == "üîô –ù–∞–∑–∞–¥")
async def back_to_menu(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if is_commander(user_id):
        await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é –∫–æ–º–∞–Ω–¥–∏—Ä–∞:", reply_markup=commander_menu)
    elif is_judge(user_id):
        await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é —Å—É–¥—å–∏:", reply_markup=judge_menu)
    else:
        await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=role_kb)
    await state.clear()

# ---- –°—É–¥–µ–π—Å–∫–∞—è –∏—Å—Ç–æ—Ä–∏—è: –æ—Ç–¥–µ–ª—å–Ω—ã–π entry-—Ö—ç–Ω–¥–ª–µ—Ä, –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–π –∫ –∫–Ω–æ–ø–∫–µ "üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π" –¥–ª—è —Å—É–¥–µ–π ----
@dp.message(F.text == "üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π")
async def judge_history_entry(message: types.Message, state: FSMContext):
    # –ï—Å–ª–∏ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Å—É–¥—å—ë–π ‚Äî –∑–∞–ø—É—Å–∫–∞–µ–º –ø–æ–ª–Ω—É—é –∏—Å—Ç–æ—Ä–∏—é –¥–ª—è —Å—É–¥–µ–π.
    if not is_judge(message.from_user.id):
        # –µ—Å–ª–∏ –Ω–µ —Å—É–¥—å—è ‚Äî —ç—Ç–æ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç—Å—è –¥—Ä—É–≥–∏–º —Ö—ç–Ω–¥–ª–µ—Ä–æ–º (–∫–æ–º–∞–Ω–¥–∏—Ä—Å–∫–∞—è –∏—Å—Ç–æ—Ä–∏—è)
        return
    await judge_history_start(message, state)

async def judge_history_start(message: types.Message, state: FSMContext):
    # –ü–æ—à–∞–≥–æ–≤—ã–π –≤—ã–±–æ—Ä –¥–ª—è —Å—É–¥–µ–π ‚Äî –≤—Å–µ –º–∞—Ç—á–∏ (—Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã)
    conn, cur = conn_cursor()
    cur.execute("""
        SELECT DISTINCT strftime('%Y', date) as year
        FROM matches
        WHERE result IS NOT NULL
        ORDER BY year DESC
    """)
    rows = cur.fetchall()
    conn.close()
    years = [r[0] for r in rows if r and r[0]]
    if not years:
        await message.answer("–ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π –ø—É—Å—Ç–∞.", reply_markup=judge_menu)
        return
    inline = InlineKeyboardMarkup(row_width=3)
    buttons = [InlineKeyboardButton(text=y, callback_data=f"jhist_year:{y}") for y in years]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="jhist_back:menu"))
    inline.add(*buttons)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–¥ (—Å—É–¥—å—è):", reply_markup=inline)
    await state.set_state(HistoryStates.choosing_year)

@dp.callback_query(F.data.startswith("jhist_year:"))
async def jhist_year_chosen(cb: types.CallbackQuery, state: FSMContext):
    year = cb.data.split(":", 1)[1]
    await state.update_data(j_year=year)

    conn, cur = conn_cursor()
    cur.execute("""
        SELECT DISTINCT strftime('%m', date) as month
        FROM matches
        WHERE result IS NOT NULL AND strftime('%Y', date)=?
        ORDER BY month
    """, (year,))
    rows = cur.fetchall()
    conn.close()
    months = [r[0] for r in rows if r and r[0]]
    if not months:
        await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –≤ —ç—Ç–æ–º –≥–æ–¥—É.", reply_markup=judge_menu)
        await cb.answer()
        await state.clear()
        return

    inline = InlineKeyboardMarkup(row_width=4)
    buttons = [InlineKeyboardButton(text=m, callback_data=f"jhist_month:{m}") for m in months]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="jhist_back:menu"))
    inline.add(*buttons)
    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω –≥–æ–¥ {year}. –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—è—Ü:", reply_markup=inline)
    await cb.answer()
    await state.set_state(HistoryStates.choosing_month)

@dp.callback_query(F.data.startswith("jhist_month:"))
async def jhist_month_chosen(cb: types.CallbackQuery, state: FSMContext):
    month = cb.data.split(":", 1)[1]
    await state.update_data(j_month=month)
    data = await state.get_data()
    year = data.get("j_year")
    conn, cur = conn_cursor()
    cur.execute("""
         SELECT DISTINCT strftime('%d', date) as day
         FROM matches
         WHERE result IS NOT NULL AND strftime('%Y', date)=? AND strftime('%m', date)=?
         ORDER BY day
    """, (year, month))
    rows = cur.fetchall()
    conn.close()
    days = [r[0] for r in rows if r and r[0]]
    if not days:
        await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –≤ —ç—Ç–æ–º –º–µ—Å—è—Ü–µ.", reply_markup=judge_menu)
        await cb.answer()
        await state.clear()
        return

    inline = InlineKeyboardMarkup(row_width=6)
    buttons = [InlineKeyboardButton(text=d, callback_data=f"jhist_day:{d}") for d in days]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="jhist_back:menu"))
    inline.add(*buttons)
    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω {year}-{month}. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å:", reply_markup=inline)
    await cb.answer()
    await state.set_state(HistoryStates.choosing_day)

@dp.callback_query(F.data.startswith("jhist_day:"))
async def jhist_day_chosen(cb: types.CallbackQuery, state: FSMContext):
    day = cb.data.split(":", 1)[1]
    data = await state.get_data()
    year = data.get("j_year")
    month = data.get("j_month")
    if not (year and month):
        await cb.message.answer("–û—à–∏–±–∫–∞: –≥–æ–¥ –∏–ª–∏ –º–µ—Å—è—Ü –Ω–µ –≤—ã–±—Ä–∞–Ω—ã.", reply_markup=judge_menu)
        await cb.answer()
        await state.clear()
        return

    y = str(year)
    m = month.zfill(2)
    d = day.zfill(2)
    date_iso = f"{y}-{m}-{d}"

    conn, cur = conn_cursor()
    cur.execute("""
        SELECT id, team1_id, team2_id, time, result, server, map
        FROM matches
        WHERE date=? AND result IS NOT NULL
        ORDER BY time
    """, (date_iso,))
    rows = cur.fetchall()
    conn.close()

    if not rows:
        await cb.message.answer(f"–ù–µ—Ç —Å—ã–≥—Ä–∞–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π –∑–∞ {date_iso}.", reply_markup=judge_menu)
        await cb.answer()
        await state.clear()
        return

    lines = []
    conn, cur = conn_cursor()
    for mid, t1, t2, tm, res, srv, mp in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        name1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        name2 = r2[0] if r2 and r2[0] else (f"ID {t2}" if t2 else "??")
        srv_text = f" | –°–µ—Ä–≤–µ—Ä: {srv}" if srv else ""
        map_text = f" | –ö–∞—Ä—Ç–∞: {mp}" if mp else ""
        lines.append(f"ID {mid}: {tm} ‚Äî {name1} vs {name2}{srv_text}{map_text} | {res}")
    conn.close()

    await cb.message.answer(f"üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π (–≤—Å–µ –∫–æ–º–∞–Ω–¥—ã) –∑–∞ {date_iso}:\n" + "\n".join(lines), reply_markup=judge_menu)
    await cb.answer()
    await state.clear()

@dp.callback_query(F.data.startswith("jhist_back:"))
async def jhist_back(cb: types.CallbackQuery, state: FSMContext):
    payload = cb.data.split(":", 1)[1]
    if payload == "menu":
        await cb.message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é —Å—É–¥—å–∏:", reply_markup=judge_menu)
        await cb.answer()
        await state.clear()
        return
    if payload == "year":
        conn, cur = conn_cursor()
        cur.execute("""
            SELECT DISTINCT strftime('%Y', date) as year
            FROM matches
            WHERE result IS NOT NULL
            ORDER BY year DESC
        """)
        rows = cur.fetchall()
        conn.close()
        years = [r[0] for r in rows if r and r[0]]
        if not years:
            await cb.message.answer("–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.", reply_markup=judge_menu)
            await cb.answer()
            await state.clear()
            return
        inline = InlineKeyboardMarkup(row_width=3)
        buttons = [InlineKeyboardButton(text=y, callback_data=f"jhist_year:{y}") for y in years]
        buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="jhist_back:menu"))
        inline.add(*buttons)
        await cb.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–¥ (—Å—É–¥—å—è):", reply_markup=inline)
        await cb.answer()
        await state.set_state(HistoryStates.choosing_year)
        return
    await cb.answer()

# --------------- –ê–¥–º–∏–Ω—Å–∫–∏–µ —Ö—ç–Ω–¥–ª–µ—Ä—ã ---------------
@dp.message(Command("accept"))
async def admin_accept(message: types.Message):
    if not is_admin(message.from_user.id):
        return
    parts = message.text.split()
    if len(parts) < 2:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /accept <user_id>")
        return
    try:
        uid = int(parts[1])
    except ValueError:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π user_id. –ü—Ä–∏–º–µ—Ä: /accept 12345678")
        return

    conn, cur = conn_cursor()
    cur.execute("SELECT role, team_name, phone FROM users WHERE user_id=?", (uid,))
    row = cur.fetchone()
    if not row:
        conn.close()
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return
    role, team_name, phone = row
    cur.execute("UPDATE users SET approved=1 WHERE user_id=?", (uid,))
    conn.commit()
    conn.close()

    try:
        if role == "commander":
            await send_safe(uid, f"‚úÖ –í–∞—à–∞ –∫–æ–º–∞–Ω–¥–∞ <b>{team_name}</b> –æ–¥–æ–±—Ä–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º. –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –º–µ–Ω—é –∫–æ–º–∞–Ω–¥–∏—Ä–∞.")
            await bot.send_message(uid, "–ú–µ–Ω—é –∫–æ–º–∞–Ω–¥–∏—Ä–∞:", reply_markup=commander_menu)
        else:
            await send_safe(uid, "‚úÖ –í—ã –æ–¥–æ–±—Ä–µ–Ω—ã –∫–∞–∫ —Å—É–¥—å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º. –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –º–µ–Ω—é —Å—É–¥—å–∏.")
            await bot.send_message(uid, "–ú–µ–Ω—é —Å—É–¥—å–∏:", reply_markup=judge_menu)
    except Exception:
        logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å —É–≤–µ–¥–æ–º–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è %s –æ–± –æ–¥–æ–±—Ä–µ–Ω–∏–∏.", uid)

    await message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} –æ–¥–æ–±—Ä–µ–Ω.")

@dp.message(Command("decline"))
async def admin_decline(message: types.Message):
    if not is_admin(message.from_user.id):
        return
    parts = message.text.split()
    if len(parts) < 2:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /decline <user_id>")
        return
    try:
        uid = int(parts[1])
    except ValueError:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π user_id. –ü—Ä–∏–º–µ—Ä: /decline 12345678")
        return

    conn, cur = conn_cursor()
    cur.execute("SELECT role, team_name FROM users WHERE user_id=?", (uid,))
    row = cur.fetchone()
    if not row:
        conn.close()
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return
    role, team_name = row
    cur.execute("DELETE FROM users WHERE user_id=?", (uid,))
    conn.commit()
    conn.close()
    try:
        await send_safe(uid, "‚ùå –í–∞—à–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception:
        pass
    await message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} –æ—Ç–∫–ª–æ–Ω—ë–Ω –∏ —É–¥–∞–ª—ë–Ω.")

@dp.message(Command("list_teams"))
async def admin_list_teams(message: types.Message):
    if not is_admin(message.from_user.id):
        return
    conn, cur = conn_cursor()
    cur.execute("SELECT user_id, team_name, phone, COALESCE(approved,0) FROM users WHERE role='commander'")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ù–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥–∏—Ä–æ–≤.")
        return
    lines = [f"ID {uid} | {team} | {phone} | {'‚úî' if a else '‚è≥'}" for uid, team, phone, a in rows]
    await message.answer("–°–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥:\n" + "\n".join(lines))

@dp.message(Command("list_judges"))
async def admin_list_judges(message: types.Message):
    if not is_admin(message.from_user.id):
        return
    conn, cur = conn_cursor()
    cur.execute("SELECT user_id, phone, COALESCE(approved,0) FROM users WHERE role='judge'")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ù–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å—É–¥–µ–π.")
        return
    lines = [f"ID {uid} | {phone} | {'‚úî' if a else '‚è≥'}" for uid, phone, a in rows]
    await message.answer("–°–ø–∏—Å–æ–∫ —Å—É–¥–µ–π:\n" + "\n".join(lines))

@dp.message(Command("del_team"))
async def admin_del_team(message: types.Message):
    if not is_admin(message.from_user.id):
        return
    parts = message.text.split()
    if len(parts) < 2:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /del_team <user_id>")
        return
    try:
        uid = int(parts[1])
    except ValueError:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π user_id.")
        return
    conn, cur = conn_cursor()
    cur.execute("DELETE FROM users WHERE user_id=? AND role='commander'", (uid,))
    conn.commit()
    conn.close()
    try:
        await send_safe(uid, "‚ùå –í–∞—à–∞ –∫–æ–º–∞–Ω–¥–∞ –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception:
        pass
    await message.answer(f"–ö–æ–º–∞–Ω–¥–∏—Ä {uid} —É–¥–∞–ª—ë–Ω.")

@dp.message(Command("del_judge"))
async def admin_del_judge(message: types.Message):
    if not is_admin(message.from_user.id):
        return
    parts = message.text.split()
    if len(parts) < 2:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /del_judge <user_id>")
        return
    try:
        uid = int(parts[1])
    except ValueError:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π user_id.")
        return
    conn, cur = conn_cursor()
    cur.execute("DELETE FROM users WHERE user_id=? AND role='judge'", (uid,))
    conn.commit()
    conn.close()
    try:
        await send_safe(uid, "‚ùå –í—ã –±—ã–ª–∏ —É–¥–∞–ª–µ–Ω—ã –∏–∑ —Å–ø–∏—Å–∫–∞ —Å—É–¥–µ–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception:
        pass
    await message.answer(f"–°—É–¥—å—è {uid} —É–¥–∞–ª—ë–Ω.")

# --------------- –ó–∞–ø—É—Å–∫ ---------------
async def main():
    logger.info("–£–¥–∞–ª—è–µ–º webhook (–µ—Å–ª–∏ –µ—Å—Ç—å) –∏ –∑–∞–ø—É—Å–∫–∞–µ–º polling")
    try:
        await bot.delete_webhook(drop_pending_updates=True)
    except Exception as e:
        logger.info("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ webhook: %s", e)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
