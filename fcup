#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
–ü–æ–ª–Ω—ã–π —Ä–∞–±–æ—á–∏–π –∫–æ–¥ –±–æ—Ç–∞ —Ç—É—Ä–Ω–∏—Ä–∞ Squad (aiogram 3.x).
–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª:
- —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É (–∫–æ–º–∞–Ω–¥–∏—Ä / —Å—É–¥—å—è)
- –∫–æ–º–∞–Ω–¥–∏—Ä—ã: —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∫–æ–º–∞–Ω–¥—ã, –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Ç—á–µ–π (–≤—ã–±–æ—Ä –¥–∞—Ç—ã –∏–∑ –±–ª–∏–∂–∞–π—à–∏—Ö 7 –¥–Ω–µ–π, –≤—Ä–µ–º—è 19:00/20:00/21:00),
  –ø—Ä–æ—Å–º–æ—Ç—Ä —Å–≤–æ–∏—Ö –∑–∞—è–≤–æ–∫, —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è, –∏—Å—Ç–æ—Ä–∏–∏ –º–∞—Ç—á–µ–π
- –∑–∞—â–∏—Ç–∞ –æ—Ç –¥—É–±–ª–µ–π (–æ–¥–Ω–æ–π –∫–æ–º–∞–Ω–¥–µ –Ω–µ–ª—å–∑—è –∏–º–µ—Ç—å –¥–≤–∞ –º–∞—Ç—á–∞ –≤ –æ–¥–Ω–æ –≤—Ä–µ–º—è)
- –ø—Ä–∏ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏ –∑–∞—è–≤–æ–∫ —Å–æ–∑–¥–∞—ë—Ç—Å—è –º–∞—Ç—á; –¥–æ –∑–∞–ø–∏—Å–∏ –≤ matches ‚Äî —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç (–∫–∞–∂–¥–∞—è –∫–æ–º–∞–Ω–¥–∞ –≤—ã–±–∏—Ä–∞–µ—Ç –∫–∞—Ä—Ç—É),
  –±–æ—Ç —Å–ª—É—á–∞–π–Ω–æ –≤—ã–±–∏—Ä–∞–µ—Ç –æ–¥–Ω—É –∏–∑ –¥–≤—É—Ö –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∫–∞—Ä—Ç –∏ —Ç–æ–ª—å–∫–æ –ø–æ—Ç–æ–º –º–∞—Ç—á —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç—Å—è
- —Å—É–¥—å–∏: —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É—é—Ç—Å—è –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É, –≤–∏–¥—è—Ç —Å–ø–∏—Å–æ–∫ –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞, –º–æ–≥—É—Ç –≤—ã–±—Ä–∞—Ç—å –º–∞—Ç—á –∏ –≤–≤–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç,
  –º–æ–≥—É—Ç —É–¥–∞–ª—è—Ç—å –º–∞—Ç—á–∏ (–ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ ‚Äî —É–¥–∞–ª—è—é—Ç—Å—è –∑–∞—è–≤–∫–∏ –∫–æ–º–∞–Ω–¥ –Ω–∞ —ç—Ç–æ –≤—Ä–µ–º—è)
- –∏—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π: –∫–æ–º–∞–Ω–¥–∏—Ä—ã –≤–∏–¥—è—Ç –∏—Å—Ç–æ—Ä–∏—é —Ç–æ–ª—å–∫–æ —Å–≤–æ–µ–π –∫–æ–º–∞–Ω–¥—ã; —Å—É–¥—å–∏ –≤–∏–¥—è—Ç –∏—Å—Ç–æ—Ä–∏—é –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥ (–≥–æ–¥->–º–µ—Å—è—Ü->–¥–µ–Ω—å)
- –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–æ–≤ (Server 1..4) ‚Äî –≤ –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ –≤—Ä–µ–º—è —Å–µ—Ä–≤–µ—Ä –∑–∞–Ω–∏–º–∞–µ—Ç –Ω–µ –±–æ–ª–µ–µ 1 –º–∞—Ç—á–∞
- –∫–Ω–æ–ø–∫–∏ –≤–æ–∑–≤—Ä–∞—Ç–∞ (–ù–∞–∑–∞–¥) –≤ –æ—Å–Ω–æ–≤–Ω—ã—Ö –¥–∏–∞–ª–æ–≥–∞—Ö
- DB: sqlite tournament.db
- –∫–∞—Ä—Ç—ã: Narva, Mutaha, Harju, Fallujah, BlackCoast, Sanxian
"""

import asyncio
import logging
import sqlite3
import random
from datetime import date, timedelta
from typing import Optional, List

from aiogram import Bot, Dispatcher, F, types
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import Command
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove,
    InlineKeyboardMarkup, InlineKeyboardButton
)
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State

# ----------------- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ -----------------
API_TOKEN = "8392821328:AAHHINFxwpSZKGRcv0vQXogGc-pnXcAZspI"   # <-- –≤—Å—Ç–∞–≤—å —Å—é–¥–∞ —Ç–æ–∫–µ–Ω
# –ï—Å–ª–∏ —Ö–æ—á–µ—à—å, —á—Ç–æ–±—ã –±–æ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–ª —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ –æ–±—â–∏–π —á–∞—Ç (–≥—Ä—É–ø–ø—É/–∫–∞–Ω–∞–ª), —É–∫–∞–∂–∏ ID:
GROUP_CHAT_ID: Optional[int] = None  # –Ω–∞–ø—Ä–∏–º–µ—Ä -1001234567890 –∏–ª–∏ None

DB_PATH = "tournament.db"

# –°–ø–∏—Å–æ–∫ —Å–µ—Ä–≤–µ—Ä–æ–≤
SERVER_LIST = ["Server 1", "Server 2", "Server 3", "Server 4"]

# –°–ø–∏—Å–æ–∫ –∫–∞—Ä—Ç
MAP_LIST = ["Narva", "Mutaha", "Harju", "Fallujah", "BlackCoast", "Sanxian"]

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --------------- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–¥ -------------
def init_db():
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()

    # —Ç–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–∫–æ–º–∞–Ω–¥–∏—Ä—ã –∏ —Å—É–¥—å–∏)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            phone TEXT,
            role TEXT,
            team_name TEXT
        )
    """)

    # –∑–∞—è–≤–∫–∏ –∫–æ–º–∞–Ω–¥ (–æ–∂–∏–¥–∞—é—Ç —Å–æ–ø–µ—Ä–Ω–∏–∫–∞)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS match_requests (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team_id INTEGER,
            date TEXT,
            time TEXT
        )
    """)

    # –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–µ –º–∞—Ç—á–∏ (—Å –ø–æ–ª–µ–º server –∏ map –µ—Å–ª–∏ –µ—Å—Ç—å)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS matches (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team1_id INTEGER,
            team2_id INTEGER,
            date TEXT,
            time TEXT,
            result TEXT,
            judge_id INTEGER,
            server TEXT,
            map TEXT
        )
    """)

    # –≤—Ä–µ–º–µ–Ω–Ω—ã–µ pending –º–∞—Ç—á–∏ –¥–æ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏—è –∫–∞—Ä—Ç—ã
    cur.execute("""
        CREATE TABLE IF NOT EXISTS pending_matches (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team1_id INTEGER,
            team2_id INTEGER,
            date TEXT,
            time TEXT,
            server TEXT,
            map_choice_team1 TEXT,
            map_choice_team2 TEXT
        )
    """)

    conn.commit()
    conn.close()

def ensure_columns():
    """
    –ü—Ä–æ–≤–µ—Ä–∫–∏/–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–ª–æ–Ω–æ–∫ –Ω–∞ —Å–ª—É—á–∞–π –∞–ø–≥—Ä–µ–π–¥–∞ –ë–î (server, map).
    """
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    cur.execute("PRAGMA table_info(matches)")
    cols = [r[1] for r in cur.fetchall()]
    if "server" not in cols:
        try:
            cur.execute("ALTER TABLE matches ADD COLUMN server TEXT")
            conn.commit()
            logger.info("–î–æ–±–∞–≤–ª–µ–Ω–∞ –∫–æ–ª–æ–Ω–∫–∞ server –≤ matches")
        except Exception as e:
            logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å –∫–æ–ª–æ–Ω–∫—É server: %s", e)
    if "map" not in cols:
        try:
            cur.execute("ALTER TABLE matches ADD COLUMN map TEXT")
            conn.commit()
            logger.info("–î–æ–±–∞–≤–ª–µ–Ω–∞ –∫–æ–ª–æ–Ω–∫–∞ map –≤ matches")
        except Exception as e:
            logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å –∫–æ–ª–æ–Ω–∫—É map: %s", e)
    conn.close()

init_db()
ensure_columns()

# --------------- FSM ---------------
class RegStates(StatesGroup):
    choosing_role = State()
    waiting_for_contact = State()
    waiting_for_team_name = State()

class ScheduleStates(StatesGroup):
    choosing_date = State()
    choosing_time = State()

class JudgeStates(StatesGroup):
    choosing_match = State()
    entering_result = State()

class DeleteStates(StatesGroup):
    choosing_delete_match = State()

class HistoryStates(StatesGroup):
    choosing_year = State()
    choosing_month = State()
    choosing_day = State()

class MapStates(StatesGroup):
    waiting_for_map_choice = State()

# --------------- –ë–æ—Ç –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä ---------------
bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher(storage=MemoryStorage())

# --------------- –£—Ç–∏–ª–∏—Ç—ã ---------------

def conn_cursor():
    conn = sqlite3.connect(DB_PATH, check_same_thread=False)
    cur = conn.cursor()
    return conn, cur

def dates_next_week_iso() -> List[str]:
    today = date.today()
    return [(today + timedelta(days=i)).isoformat() for i in range(7)]

async def send_safe(user_id: int, text: str):
    try:
        await bot.send_message(user_id, text)
    except Exception as e:
        logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ª–∏—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ %s: %s", user_id, e)

def user_team_name(user_id: int) -> Optional[str]:
    conn, cur = conn_cursor()
    cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return r[0] if r and r[0] else None

def is_commander(user_id: int) -> bool:
    conn, cur = conn_cursor()
    cur.execute("SELECT role FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return bool(r and r[0] == "commander")

def is_judge(user_id: int) -> bool:
    conn, cur = conn_cursor()
    cur.execute("SELECT role FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return bool(r and r[0] == "judge")

def has_match(team_id: int, date_iso: str, time_val: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ —É –∫–æ–º–∞–Ω–¥—ã –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –º–∞—Ç—á –≤ —ç—Ç–æ—Ç —Å–ª–æ—Ç."""
    conn, cur = conn_cursor()
    cur.execute("""
        SELECT 1 FROM matches
        WHERE (team1_id=? OR team2_id=?) AND date=? AND time=?
    """, (team_id, team_id, date_iso, time_val))
    r = cur.fetchone()
    conn.close()
    return r is not None

def remove_request(team_id: int, date_iso: str, time_val: str):
    conn, cur = conn_cursor()
    cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (team_id, date_iso, time_val))
    conn.commit()
    conn.close()

def get_used_servers(date_iso: str, time_val: str) -> List[str]:
    conn, cur = conn_cursor()
    cur.execute("SELECT server FROM matches WHERE date=? AND time=? AND server IS NOT NULL", (date_iso, time_val))
    rows = cur.fetchall()
    conn.close()
    return [r[0] for r in rows if r and r[0]]

def pick_free_server(date_iso: str, time_val: str) -> Optional[str]:
    used = set(get_used_servers(date_iso, time_val))
    for s in SERVER_LIST:
        if s not in used:
            return s
    return None

# --------------- –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---------------
role_kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä"), KeyboardButton(text="‚öñÔ∏è –Ø - —Å—É–¥—å—è")]
    ],
    resize_keyboard=True
)

contact_kb = ReplyKeyboardMarkup(
    keyboard=[[KeyboardButton(text="üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º", request_contact=True)]],
    resize_keyboard=True,
    one_time_keyboard=True
)

commander_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É"), KeyboardButton(text="üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")],
        [KeyboardButton(text="üìú –ú–æ–∏ –º–∞—Ç—á–∏"), KeyboardButton(text="üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π")]
    ],
    resize_keyboard=True
)

# –£ —Å—É–¥–µ–π: –∑–∞–º–µ–Ω–∏–ª–∏ "—Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É" –Ω–∞ "–ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π"
judge_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìù –í–Ω–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç"), KeyboardButton(text="üìú –í—Å–µ –º–∞—Ç—á–∏")],
        [KeyboardButton(text="üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π"), KeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –º–∞—Ç—á")]
    ],
    resize_keyboard=True
)

back_kb = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="üîô –ù–∞–∑–∞–¥")]], resize_keyboard=True)

# --------------- –•—ç–Ω–¥–ª–µ—Ä—ã ---------------

@dp.message(Command("start"))
async def cmd_start(message: types.Message, state: FSMContext):
    """/start - –ø–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Ä–æ–ª–∏ –∏–ª–∏ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é, –µ—Å–ª–∏ —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω"""
    conn, cur = conn_cursor()
    cur.execute("SELECT role, team_name FROM users WHERE user_id=?", (message.from_user.id,))
    r = cur.fetchone()
    conn.close()

    if r:
        role, team_name = r
        if role == "commander":
            await message.answer("–í—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä.", reply_markup=commander_menu)
        elif role == "judge":
            await message.answer("–í—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è.", reply_markup=judge_menu)
        else:
            await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å:", reply_markup=role_kb)
    else:
        await message.answer("–ü—Ä–∏–≤–µ—Ç! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å:", reply_markup=role_kb)
        await state.set_state(RegStates.choosing_role)

# ---- –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Ä–æ–ª–∏ –∏ —Ç–µ–ª–µ—Ñ–æ–Ω ----
@dp.message(RegStates.choosing_role, F.text.in_(["üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä", "‚öñÔ∏è –Ø - —Å—É–¥—å—è"]))
async def choose_role(message: types.Message, state: FSMContext):
    role = "commander" if message.text == "üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä" else "judge"
    await state.update_data(chosen_role=role)
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–∫–Ω–æ–ø–∫–∞):", reply_markup=contact_kb)
    await state.set_state(RegStates.waiting_for_contact)

@dp.message(RegStates.waiting_for_contact, F.content_type == types.ContentType.CONTACT)
async def got_contact(message: types.Message, state: FSMContext):
    contact = message.contact
    phone = contact.phone_number if contact else None
    data = await state.get_data()
    role = data.get("chosen_role")
    user_id = message.from_user.id

    conn, cur = conn_cursor()
    cur.execute("INSERT OR REPLACE INTO users (user_id, phone, role, team_name) VALUES (?, ?, ?, COALESCE((SELECT team_name FROM users WHERE user_id=?), NULL))",
                (user_id, phone, role, user_id))
    conn.commit()
    conn.close()

    if role == "commander":
        # –∑–∞–ø—Ä–æ—Å–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã
        await message.answer("–û—Ç–ª–∏—á–Ω–æ ‚Äî —Ç–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã (–æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ):", reply_markup=ReplyKeyboardRemove())
        await state.set_state(RegStates.waiting_for_team_name)
    else:
        # —Å—É–¥—å—è –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω
        await message.answer("‚úÖ –í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è.", reply_markup=judge_menu)
        await state.clear()

@dp.message(RegStates.waiting_for_team_name, F.text)
async def got_team_name(message: types.Message, state: FSMContext):
    team_name = message.text.strip()
    if not team_name:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ –µ—â—ë —Ä–∞–∑:")
        return

    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("UPDATE users SET team_name=? WHERE user_id=?", (team_name, user_id))
    conn.commit()
    conn.close()

    await message.answer(f"‚úÖ –ö–æ–º–∞–Ω–¥–∞ <b>{team_name}</b> –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞!", reply_markup=commander_menu)
    await state.clear()

# ---- –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Ç—á–∞: –¥–∞—Ç–∞ -> –≤—Ä–µ–º—è -> —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∑–∞—è–≤–∫–∏/–æ–∂–∏–¥–∞–Ω–∏–µ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –∏ –∫–∞—Ä—Ç ----
@dp.message(F.text == "üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É")
async def start_schedule(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if not is_commander(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ –∫–æ–º–∞–Ω–¥–∏—Ä—ã –º–æ–≥—É—Ç –Ω–∞–∑–Ω–∞—á–∞—Ç—å –∏–≥—Ä—ã. –°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä.")
        return
    # –ø—Ä–æ–≤–µ—Ä–∏–º, –µ—Å—Ç—å –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è team_name
    tname = user_team_name(user_id)
    if not tname:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã (—á–µ—Ä–µ–∑ /start).")
        return

    dates = dates_next_week_iso()
    inline = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=d, callback_data=f"slot_date:{d}")] for d in dates
    ])
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π):", reply_markup=inline)
    await state.set_state(ScheduleStates.choosing_date)

@dp.callback_query(F.data.startswith("slot_date:"))
async def on_date_chosen(cb: types.CallbackQuery, state: FSMContext):
    date_iso = cb.data.split(":", 1)[1]
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="19:00", callback_data=f"slot_time:{date_iso}|19:00")],
        [InlineKeyboardButton(text="20:00", callback_data=f"slot_time:{date_iso}|20:00")],
        [InlineKeyboardButton(text="21:00", callback_data=f"slot_time:{date_iso}|21:00")],
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="slot_back")]
    ])
    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω–∞ –¥–∞—Ç–∞ <b>{date_iso}</b>. –í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è:", reply_markup=kb)
    await cb.answer()
    await state.update_data(chosen_date=date_iso)
    await state.set_state(ScheduleStates.choosing_time)

@dp.callback_query(F.data == "slot_back")
async def slot_back(cb: types.CallbackQuery, state: FSMContext):
    # –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –≤—ã–±–æ—Ä—É –¥–∞—Ç—ã
    dates = dates_next_week_iso()
    inline = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=d, callback_data=f"slot_date:{d}")] for d in dates
    ])
    await cb.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π):", reply_markup=inline)
    await cb.answer()
    await state.set_state(ScheduleStates.choosing_date)

@dp.callback_query(F.data.startswith("slot_time:"))
async def on_time_chosen(cb: types.CallbackQuery, state: FSMContext):
    """
    –ö–æ–≥–¥–∞ —Å–æ–ø–µ—Ä–Ω–∏–∫ –Ω–∞–π–¥–µ–Ω: —Å–æ–∑–¥–∞—ë–º pending_match, –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º —Å–≤–æ–±–æ–¥–Ω—ã–π —Å–µ—Ä–≤–µ—Ä,
    –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–µ–∏–º –∫–æ–º–∞–Ω–¥–∞–º –≤—ã–±–æ—Ä –∫–∞—Ä—Ç—ã. –¢–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –æ–±–µ–∏—Ö –∫–∞—Ä—Ç ‚Äî
    –º–∞—Ç—á –ø–µ—Ä–µ–Ω–æ—Å–∏—Ç—Å—è –≤ matches.
    """
    payload = cb.data.split(":", 1)[1]
    date_iso, time_val = payload.split("|", 1)
    user_id = cb.from_user.id

    # –ø—Ä–æ–≤–µ—Ä–∫–∞: —É —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã —É–∂–µ –µ—Å—Ç—å –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –º–∞—Ç—á –≤ —ç—Ç–æ—Ç —Å–ª–æ—Ç?
    if has_match(user_id, date_iso, time_val):
        await cb.message.answer("‚ùå –£ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã —É–∂–µ –Ω–∞–∑–Ω–∞—á–µ–Ω –º–∞—Ç—á –≤ —ç—Ç–æ—Ç –¥–µ–Ω—å/–≤—Ä–µ–º—è.")
        await cb.answer()
        await state.clear()
        return

    # –ø—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å—Ç—å –ª–∏ —É–∂–µ –∑–∞—è–≤–∫–∞ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç
    conn, cur = conn_cursor()
    cur.execute("SELECT id FROM match_requests WHERE team_id=? AND date=? AND time=?", (user_id, date_iso, time_val))
    if cur.fetchone():
        conn.close()
        await cb.message.answer("–£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –∑–∞—è–≤–∫–∞ –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç ‚Äî –∂–¥—ë–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.")
        await cb.answer()
        await state.clear()
        return

    # –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞—è–≤–∫—É
    cur.execute("INSERT INTO match_requests (team_id, date, time) VALUES (?, ?, ?)", (user_id, date_iso, time_val))
    conn.commit()

    # –∏—â–µ–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞: –±–µ—Ä—ë–º –∑–∞—è–≤–∫—É –¥—Ä—É–≥–æ–π –∫–æ–º–∞–Ω–¥—ã –Ω–∞ —Ç–æ—Ç –∂–µ —Å–ª–æ—Ç, –∏—Å–∫–ª—é—á–∞—è —Ç–µ, —É –∫–æ–≥–æ —É–∂–µ match
    cur.execute("SELECT id, team_id FROM match_requests WHERE date=? AND time=? AND team_id!=?", (date_iso, time_val, user_id))
    candidates = cur.fetchall()
    opponent_req = None
    for row in candidates:
        req_id, candidate_team_id = row
        if has_match(candidate_team_id, date_iso, time_val):
            continue
        opponent_req = (req_id, candidate_team_id)
        break

    if opponent_req:
        req_id, opp_team_id = opponent_req

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–≤–æ–±–æ–¥–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç
        free_server = pick_free_server(date_iso, time_val)
        if not free_server:
            # –í—Å–µ —Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–Ω—è—Ç—ã ‚Äî –Ω–µ —Å–æ–∑–¥–∞—ë–º –º–∞—Ç—á, —É–≤–µ–¥–æ–º–ª—è–µ–º –æ–±–µ –∫–æ–º–∞–Ω–¥—ã. –ó–∞—è–≤–∫–∏ –æ—Å—Ç–∞—é—Ç—Å—è.
            cur.execute("SELECT team_name FROM users WHERE user_id=?", (opp_team_id,))
            t1 = cur.fetchone()
            t1_name = t1[0] if t1 and t1[0] else f"ID {opp_team_id}"
            cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
            t2 = cur.fetchone()
            t2_name = t2[0] if t2 and t2[0] else f"ID {user_id}"

            text = f"‚ö†Ô∏è –ù–∞ {date_iso} {time_val} –≤—Å–µ —Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–Ω—è—Ç—ã. –ú–∞—Ç—á –º–µ–∂–¥—É {t1_name} –∏ {t2_name} –ø–æ–∫–∞ –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω ‚Äî –∑–∞—è–≤–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã (–æ–∂–∏–¥–∞–µ–º —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞)."
            await send_safe(opp_team_id, text)
            await send_safe(user_id, text)
            if GROUP_CHAT_ID:
                try:
                    await bot.send_message(GROUP_CHAT_ID, f"–ü–æ–ø—ã—Ç–∫–∞ –Ω–∞–∑–Ω–∞—á–∏—Ç—å –º–∞—Ç—á {t1_name} vs {t2_name} –Ω–∞ {date_iso} {time_val}, –Ω–æ –≤—Å–µ —Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–Ω—è—Ç—ã.")
                except Exception as e:
                    logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ GROUP_CHAT_ID: %s", e)
            conn.close()
            await cb.message.answer("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç –≤—Å–µ —Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–Ω—è—Ç—ã ‚Äî –≤–∞—à–∞ –∑–∞—è–≤–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –∏ –∂–¥—ë—Ç —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞.")
            await cb.answer()
            await state.clear()
            return

        # –°–æ–∑–¥–∞—ë–º pending_match (team1 = opp_team_id ‚Äî —Ç–æ—Ç, –∫—Ç–æ –±—ã–ª –≤ –∑–∞—è–≤–∫–µ —Ä–∞–Ω—å—à–µ)
        cur.execute(
            "INSERT INTO pending_matches (team1_id, team2_id, date, time, server, map_choice_team1, map_choice_team2) VALUES (?, ?, ?, ?, ?, NULL, NULL)",
            (opp_team_id, user_id, date_iso, time_val, free_server)
        )
        pending_id = cur.lastrowid
        conn.commit()

        # —É–≤–µ–¥–æ–º–ª—è–µ–º –æ–±–µ –∫–æ–º–∞–Ω–¥—ã: –ø—Ä–æ—Å–∏–º –≤—ã–±—Ä–∞—Ç—å –∫–∞—Ä—Ç—É (–∏–Ω–ª–∞–π–Ω)
        def make_map_kb(pending_id):
            rows = []
            # Create rows with up to 3 buttons per row for readability
            row = []
            for i, m in enumerate(MAP_LIST, 1):
                row.append(InlineKeyboardButton(text=m, callback_data=f"map_pick:{pending_id}:{m}"))
                if i % 3 == 0:
                    rows.append(row)
                    row = []
            if row:
                rows.append(row)
            # add cancel/back? not needed here; they must choose
            return InlineKeyboardMarkup(inline_keyboard=rows)

        kb = make_map_kb(pending_id)

        # –ü–æ–ª—É—á–∞–µ–º –∏–º–µ–Ω–∞ –∫–æ–º–∞–Ω–¥ –¥–ª—è —Ç–µ–∫—Å—Ç–∞
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (opp_team_id,))
        t1 = cur.fetchone()
        t1_name = t1[0] if t1 and t1[0] else f"ID {opp_team_id}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
        t2 = cur.fetchone()
        t2_name = t2[0] if t2 and t2[0] else f"ID {user_id}"

        text1 = (f"üîî –ù–∞–π–¥–µ–Ω —Å–æ–ø–µ—Ä–Ω–∏–∫ –¥–ª—è –≤–∞—à–µ–π –∑–∞—è–≤–∫–∏!\n"
                 f"–ú–∞—Ç—á: {t1_name} vs {t2_name}\n"
                 f"üìÖ {date_iso} ‚è∞ {time_val}\n"
                 f"üåê –°–µ—Ä–≤–µ—Ä: {free_server}\n\n"
                 f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç—É (–≤–∞—à –≤—ã–±–æ—Ä –±—É–¥–µ—Ç —É—á—Ç—ë–Ω –ø—Ä–∏ –≤—ã–±–æ—Ä–µ –∏—Ç–æ–≥–æ–≤–æ–π –∫–∞—Ä—Ç—ã):")
        text2 = (f"üîî –ù–∞–π–¥–µ–Ω —Å–æ–ø–µ—Ä–Ω–∏–∫ –¥–ª—è –≤–∞—à–µ–π –∑–∞—è–≤–∫–∏!\n"
                 f"–ú–∞—Ç—á: {t1_name} vs {t2_name}\n"
                 f"üìÖ {date_iso} ‚è∞ {time_val}\n"
                 f"üåê –°–µ—Ä–≤–µ—Ä: {free_server}\n\n"
                 f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç—É (–≤–∞—à –≤—ã–±–æ—Ä –±—É–¥–µ—Ç —É—á—Ç—ë–Ω –ø—Ä–∏ –≤—ã–±–æ—Ä–µ –∏—Ç–æ–≥–æ–≤–æ–π –∫–∞—Ä—Ç—ã):")

        # send to both
        await send_safe(opp_team_id, text1)
        await send_safe(user_id, text2)
        # send inline keyboards to both via direct messages (so they tap)
        try:
            await bot.send_message(opp_team_id, "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç—É –¥–ª—è –º–∞—Ç—á–∞:", reply_markup=kb)
        except Exception:
            logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—ã–±–æ—Ä –∫–∞—Ä—Ç—ã –∫–æ–º–∞–Ω–¥–µ %s", opp_team_id)
        try:
            await bot.send_message(user_id, "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç—É –¥–ª—è –º–∞—Ç—á–∞:", reply_markup=kb)
        except Exception:
            logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—ã–±–æ—Ä –∫–∞—Ä—Ç—ã –∫–æ–º–∞–Ω–¥–µ %s", user_id)

        # –≥—Ä—É–ø–ø–æ–≤–æ–π —É–≤–µ–¥–æ–º ‚Äî —á—Ç–æ –º–∞—Ç—á –æ–∂–∏–¥–∞–µ—Ç –≤—ã–±–æ—Ä–∞ –∫–∞—Ä—Ç
        if GROUP_CHAT_ID:
            try:
                await bot.send_message(GROUP_CHAT_ID, f"–ú–∞—Ç—á –æ–∂–∏–¥–∞–µ—Ç –≤—ã–±–æ—Ä–∞ –∫–∞—Ä—Ç: {t1_name} vs {t2_name} ‚Äî {date_iso} {time_val} ‚Äî –°–µ—Ä–≤–µ—Ä: {free_server}")
            except Exception as e:
                logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ GROUP_CHAT_ID: %s", e)

        # —É–¥–∞–ª—è–µ–º –∑–∞—è–≤–∫–∏? –Ω–µ—Ç ‚Äî –ø—É—Å—Ç—å –∑–∞—è–≤–∫–∏ —Å—É—â–µ—Å—Ç–≤—É—é—Ç until match confirmed; but we remove them after match is confirmed (we already planned to delete them when finalizing)
        # –î–ª—è —è—Å–Ω–æ—Å—Ç–∏ –∑–∞—è–≤–∫–∏ –º–æ–∂–Ω–æ –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å ‚Äî –ø—Ä–∏ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º —Å–æ–∑–¥–∞–Ω–∏–∏ –º–∞—Ç—á–µ–π –º—ã —É–¥–∞–ª–∏–º –∑–∞—è–≤–∫–∏.
        await cb.message.answer("–°–æ–ø–µ—Ä–Ω–∏–∫ –Ω–∞–π–¥–µ–Ω ‚Äî –æ–∂–∏–¥–∞–µ–º –≤—ã–±–æ—Ä–∞ –∫–∞—Ä—Ç –æ–±–µ–∏–º–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏. –ü–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –∫–∞—Ä—Ç–∞ –±—É–¥–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –∏ –º–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω.")
        await cb.answer()
        conn.close()
        await state.clear()
        return

    # –µ—Å–ª–∏ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –Ω–µ—Ç ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º –∑–∞—è–≤–∫—É –∏ –∂–¥—ë–º
    conn.close()
    await cb.message.answer(f"‚úÖ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –Ω–∞ {date_iso} {time_val}. –û–∂–∏–¥–∞–µ–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.")
    await cb.answer()
    await state.clear()

# ---- –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –∫–∞—Ä—Ç—ã (callback) ----
@dp.callback_query(F.data.startswith("map_pick:"))
async def on_map_pick(cb: types.CallbackQuery):
    """
    Callback data: map_pick:{pending_id}:{map_name}
    –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫—Ç–æ –Ω–∞–∂–∞–ª (team1 –∏–ª–∏ team2) –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±–æ—Ä.
    –ï—Å–ª–∏ –æ–±–∞ –≤—ã–±—Ä–∞–ª–∏ ‚Äî —Å–ª—É—á–∞–π–Ω–æ –≤—ã–±–∏—Ä–∞–µ–º –∏—Ç–æ–≥–æ–≤—É—é –∫–∞—Ä—Ç—É –∏–∑ –¥–≤—É—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, —Å–æ–∑–¥–∞—ë–º –∑–∞–ø–∏—Å—å –≤ matches,
    —É–¥–∞–ª—è–µ–º pending_matches, —É–¥–∞–ª—è–µ–º –∑–∞—è–≤–∫–∏ –æ–±–µ–∏—Ö –∫–æ–º–∞–Ω–¥ –∏ —É–≤–µ–¥–æ–º–ª—è–µ–º –∫–æ–º–∞–Ω–¥—ã/–≥—Ä—É–ø–ø—É.
    """
    try:
        _, payload = cb.data.split(":", 1)
        pending_id_str, map_choice = payload.split(":", 1)
        pending_id = int(pending_id_str)
    except Exception:
        await cb.answer("–ù–µ–≤–µ—Ä–Ω—ã–π callback.")
        return

    user_id = cb.from_user.id
    conn, cur = conn_cursor()
    cur.execute("SELECT team1_id, team2_id, date, time, server, map_choice_team1, map_choice_team2 FROM pending_matches WHERE id=?", (pending_id,))
    row = cur.fetchone()
    if not row:
        conn.close()
        await cb.answer("–≠—Ç–æ—Ç –º–∞—Ç—á —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return

    team1_id, team2_id, date_iso, time_val, server, m1, m2 = row

    # –ø—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ –Ω–∞–∂–∞—Ç–∏–µ –¥–µ–ª–∞–µ—Ç –∏–º–µ–Ω–Ω–æ –∫–æ–º–∞–Ω–¥–∏—Ä –æ–¥–Ω–æ–π –∏–∑ —É—á–∞–≤—Å—Ç–≤—É—é—â–∏—Ö –∫–æ–º–∞–Ω–¥
    if user_id != team1_id and user_id != team2_id:
        conn.close()
        await cb.answer("–í—ã –Ω–µ —É—á–∞—Å—Ç–≤—É–µ—Ç–µ –≤ —ç—Ç–æ–º –º–∞—Ç—á–µ.")
        return

    # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±–æ—Ä
    if user_id == team1_id:
        cur.execute("UPDATE pending_matches SET map_choice_team1=? WHERE id=?", (map_choice, pending_id))
        conn.commit()
        await cb.answer(f"–í—ã –≤—ã–±—Ä–∞–ª–∏ –∫–∞—Ä—Ç—É: {map_choice}")
    else:
        cur.execute("UPDATE pending_matches SET map_choice_team2=? WHERE id=?", (map_choice, pending_id))
        conn.commit()
        await cb.answer(f"–í—ã –≤—ã–±—Ä–∞–ª–∏ –∫–∞—Ä—Ç—É: {map_choice}")

    # –ø—Ä–æ–≤–µ—Ä—è–µ–º, –≤—ã–±—Ä–∞–ª–∞ –ª–∏ –≤—Ç–æ—Ä–∞—è –∫–æ–º–∞–Ω–¥–∞
    cur.execute("SELECT map_choice_team1, map_choice_team2 FROM pending_matches WHERE id=?", (pending_id,))
    row2 = cur.fetchone()
    if not row2:
        conn.close()
        return
    choice1, choice2 = row2

    # –µ—Å–ª–∏ –æ–±–∞ –≤—ã–±–æ—Ä–∞ –µ—Å—Ç—å ‚Äî —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –º–∞—Ç—á
    if choice1 and choice2:
        # –≤—ã–±—Ä–∞—Ç—å –∏—Ç–æ–≥–æ–≤—É—é –∫–∞—Ä—Ç—É —Å–ª—É—á–∞–π–Ω–æ –∏–∑ –¥–≤—É—Ö –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö
        final_map = random.choice([choice1, choice2])
        # —Å–æ–∑–¥–∞—ë–º –∑–∞–ø–∏—Å—å –≤ matches
        cur.execute("INSERT INTO matches (team1_id, team2_id, date, time, server, map) VALUES (?, ?, ?, ?, ?, ?)",
                    (team1_id, team2_id, date_iso, time_val, server, final_map))
        match_id = cur.lastrowid
        # —É–¥–∞–ª—è–µ–º pending
        cur.execute("DELETE FROM pending_matches WHERE id=?", (pending_id,))
        # —É–¥–∞–ª—è–µ–º –∑–∞—è–≤–∫–∏ –æ–±–µ–∏—Ö –∫–æ–º–∞–Ω–¥ –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç (–µ—Å–ª–∏ –æ—Å—Ç–∞–ª–∏—Å—å)
        try:
            cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (team1_id, date_iso, time_val))
            cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (team2_id, date_iso, time_val))
        except Exception:
            logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞—è–≤–æ–∫ –ø—Ä–∏ —Ñ–∏–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ –º–∞—Ç—á–∞.")
        conn.commit()

        # —É–≤–µ–¥–æ–º–ª—è–µ–º –∫–æ–º–∞–Ω–¥—ã
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (team1_id,))
        r1 = cur.fetchone()
        n1 = r1[0] if r1 and r1[0] else f"ID {team1_id}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (team2_id,))
        r2 = cur.fetchone()
        n2 = r2[0] if r2 and r2[0] else f"ID {team2_id}"

        text = (f"‚öîÔ∏è <b>–ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω</b>!\n"
                f"ID {match_id}\n"
                f"üìÖ {date_iso} ‚è∞ {time_val}\n"
                f"üèÜ {n1} vs {n2}\n"
                f"üåê –°–µ—Ä–≤–µ—Ä: {server}\n"
                f"üó∫ –ö–∞—Ä—Ç–∞: {final_map}")
        # –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –õ–° –æ–±–µ–∏–º –∫–æ–º–∞–Ω–¥–∞–º
        await send_safe(team1_id, text)
        await send_safe(team2_id, text)
        # –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ group chat, –µ—Å–ª–∏ –∑–∞–¥–∞–Ω
        if GROUP_CHAT_ID:
            try:
                await bot.send_message(GROUP_CHAT_ID, text)
            except Exception:
                pass

        await cb.message.answer(f"–ú–∞—Ç—á –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ –Ω–∞–∑–Ω–∞—á–µ–Ω: {n1} vs {n2} (ID {match_id}). –ö–∞—Ä—Ç–∞: {final_map}", reply_markup=ReplyKeyboardRemove())
        conn.close()
        return

    conn.close()
    # –µ—Å–ª–∏ –≤—Ç–æ—Ä–æ–π –µ—â—ë –Ω–µ –≤—ã–±—Ä–∞–ª ‚Äî –ø—Ä–æ—Å—Ç–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —É–∂–µ –¥–∞–Ω–æ
    await cb.message.answer("–í–∞—à –≤—ã–±–æ—Ä –ø—Ä–∏–Ω—è—Ç. –û–∂–∏–¥–∞–µ–º –≤—ã–±–æ—Ä —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.")
    return

# ---- –ü—Ä–æ—Å–º–æ—Ç—Ä –∑–∞—è–≤–æ–∫ / —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è / –º–∞—Ç—á–∏ –¥–ª—è –∫–æ–º–∞–Ω–¥–∏—Ä–æ–≤ ----
@dp.message(F.text == "üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
async def my_requests(message: types.Message):
    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("SELECT date, time FROM match_requests WHERE team_id=?", (user_id,))
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞—è–≤–æ–∫.")
        return
    lines = [f"{d} {t}" for d, t in rows]
    await message.answer("üìÖ –í–∞—à–∏ –∑–∞—è–≤–∫–∏:\n" + "\n".join(lines))

@dp.message(F.text == "üìú –ú–æ–∏ –º–∞—Ç—á–∏")
async def my_matches(message: types.Message):
    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time, result, server, map FROM matches WHERE team1_id=? OR team2_id=?", (user_id, user_id))
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–£ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã –ø–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π.")
        return
    # –§–æ—Ä–º–∏—Ä—É–µ–º –≤—ã–≤–æ–¥
    text_lines = []
    conn, cur = conn_cursor()
    for mid, t1, t2, d, tm, res, srv, mp in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        n2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        srv_text = f" | –°–µ—Ä–≤–µ—Ä: {srv}" if srv else ""
        map_text = f" | –ö–∞—Ä—Ç–∞: {mp}" if mp else ""
        text_lines.append(f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2}{srv_text}{map_text} | {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –∑–∞–¥–∞–Ω'}")
    conn.close()
    await message.answer("üìú –í–∞—à–∏ –º–∞—Ç—á–∏:\n" + "\n".join(text_lines))

# ---- –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π –¥–ª—è –∫–æ–º–∞–Ω–¥–∏—Ä–æ–≤ (–≥–æ–¥ -> –º–µ—Å—è—Ü -> –¥–µ–Ω—å) ----
@dp.message(F.text == "üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π")
async def history_start(message: types.Message, state: FSMContext):
    """
    –î–ª—è –∫–æ–º–∞–Ω–¥–∏—Ä–æ–≤ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é —Ç–æ–ª—å–∫–æ –∏—Ö –∫–æ–º–∞–Ω–¥—ã (—Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã).
    –î–ª—è —Å—É–¥–µ–π —ç—Ç–æ—Ç –∂–µ —Ö—ç–Ω–¥–ª–µ—Ä —Ç–∞–∫–∂–µ –∑–∞–ø—É—Å—Ç–∏—Ç —Å—É–¥–µ–π—Å–∫–∏–π –ø—É—Ç—å (—Å–º judge_history_start).
    """
    user_id = message.from_user.id

    if is_judge(user_id):
        # –∑–∞–ø—É—Å—Ç–∏—Ç—å —Å—É–¥–µ–π—Å–∫–∏–π –ø—É—Ç—å
        await judge_history_start(message, state)
        return

    # –∫–æ–º–∞–Ω–¥–∏—Ä—Å–∫–∞—è –ª–æ–≥–∏–∫–∞:
    conn, cur = conn_cursor()
    cur.execute("""
        SELECT DISTINCT strftime('%Y', date) as year
        FROM matches
        WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL
        ORDER BY year DESC
    """, (user_id, user_id))
    rows = cur.fetchall()
    conn.close()

    years = [r[0] for r in rows if r and r[0]]
    if not years:
        await message.answer("–ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π –ø—É—Å—Ç–∞.", reply_markup=commander_menu)
        return

    inline = InlineKeyboardMarkup(row_width=2)
    buttons = []
    for y in years:
        buttons.append(InlineKeyboardButton(text=y, callback_data=f"hist_year:{y}"))
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:menu"))
    inline.add(*buttons)

    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–¥:", reply_markup=inline)
    await state.set_state(HistoryStates.choosing_year)

@dp.callback_query(F.data.startswith("hist_year:"))
async def history_year_chosen(cb: types.CallbackQuery, state: FSMContext):
    year = cb.data.split(":", 1)[1]
    user_id = cb.from_user.id

    await state.update_data(year=year)

    conn, cur = conn_cursor()
    cur.execute("""
        SELECT DISTINCT strftime('%m', date) as month
        FROM matches
        WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL AND strftime('%Y', date)=?
        ORDER BY month
    """, (user_id, user_id, year))
    rows = cur.fetchall()
    conn.close()

    months = [r[0] for r in rows if r and r[0]]
    if not months:
        await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –≤ —ç—Ç–æ–º –≥–æ–¥—É.", reply_markup=commander_menu)
        await cb.answer()
        await state.clear()
        return

    inline = InlineKeyboardMarkup(row_width=3)
    buttons = [InlineKeyboardButton(text=m, callback_data=f"hist_month:{m}") for m in months]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:year"))
    inline.add(*buttons)

    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω –≥–æ–¥ {year}. –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—è—Ü:", reply_markup=inline)
    await cb.answer()
    await state.set_state(HistoryStates.choosing_month)

@dp.callback_query(F.data.startswith("hist_month:"))
async def history_month_chosen(cb: types.CallbackQuery, state: FSMContext):
    month = cb.data.split(":", 1)[1]
    user_id = cb.from_user.id

    await state.update_data(month=month)
    data = await state.get_data()
    year = data.get("year")

    conn, cur = conn_cursor()
    cur.execute("""
        SELECT DISTINCT strftime('%d', date) as day
        FROM matches
        WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL
          AND strftime('%Y', date)=? AND strftime('%m', date)=?
        ORDER BY day
    """, (user_id, user_id, year, month))
    rows = cur.fetchall()
    conn.close()

    days = [r[0] for r in rows if r and r[0]]
    if not days:
        await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –≤ —ç—Ç–æ–º –º–µ—Å—è—Ü–µ.", reply_markup=commander_menu)
        await cb.answer()
        await state.clear()
        return

    inline = InlineKeyboardMarkup(row_width=4)
    buttons = [InlineKeyboardButton(text=d, callback_data=f"hist_day:{d}") for d in days]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:month"))
    inline.add(*buttons)

    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω {year}-{month}. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å:", reply_markup=inline)
    await cb.answer()
    await state.set_state(HistoryStates.choosing_day)

@dp.callback_query(F.data.startswith("hist_day:"))
async def history_day_chosen(cb: types.CallbackQuery, state: FSMContext):
    day = cb.data.split(":", 1)[1]
    data = await state.get_data()
    year = data.get("year")
    month = data.get("month")
    user_id = cb.from_user.id

    y = year
    m = month.zfill(2)
    d = day.zfill(2)
    date_iso = f"{y}-{m}-{d}"

    conn, cur = conn_cursor()
    cur.execute("""
        SELECT id, team1_id, team2_id, time, result, server, map
        FROM matches
        WHERE date=? AND (team1_id=? OR team2_id=?)
        ORDER BY time
    """, (date_iso, user_id, user_id))
    rows = cur.fetchall()
    conn.close()

    if not rows:
        await cb.message.answer(f"–ú–∞—Ç—á–µ–π –∑–∞ {date_iso} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", reply_markup=commander_menu)
        await cb.answer()
        await state.clear()
        return

    lines = []
    for mid, t1, t2, tm, res, srv, mp in rows:
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        name1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        name2 = r2[0] if r2 and r2[0] else (f"ID {t2}" if t2 else "??")
        conn.close()
        srv_text = f" | –°–µ—Ä–≤–µ—Ä: {srv}" if srv else ""
        map_text = f" | –ö–∞—Ä—Ç–∞: {mp}" if mp else ""
        lines.append(f"ID {mid}: {tm} ‚Äî {name1} vs {name2}{srv_text}{map_text} | {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –∑–∞–¥–∞–Ω'}")

    await cb.message.answer(f"üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π –∑–∞ {date_iso}:\n" + "\n".join(lines), reply_markup=commander_menu)
    await cb.answer()
    await state.clear()

@dp.callback_query(F.data.startswith("hist_back:"))
async def history_back(cb: types.CallbackQuery, state: FSMContext):
    payload = cb.data.split(":", 1)[1]
    user_id = cb.from_user.id

    if payload == "menu":
        await cb.message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é –∫–æ–º–∞–Ω–¥–∏—Ä–∞:", reply_markup=commander_menu)
        await cb.answer()
        await state.clear()
        return

    if payload == "year":
        conn, cur = conn_cursor()
        cur.execute("""
            SELECT DISTINCT strftime('%Y', date) as year
            FROM matches
            WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL
            ORDER BY year DESC
        """, (user_id, user_id))
        rows = cur.fetchall()
        conn.close()
        years = [r[0] for r in rows if r and r[0]]
        if not years:
            await cb.message.answer("–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.", reply_markup=commander_menu)
            await cb.answer()
            await state.clear()
            return
        inline = InlineKeyboardMarkup(row_width=2)
        buttons = [InlineKeyboardButton(text=y, callback_data=f"hist_year:{y}") for y in years]
        buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:menu"))
        inline.add(*buttons)
        await cb.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–¥:", reply_markup=inline)
        await cb.answer()
        await state.set_state(HistoryStates.choosing_year)
        return

    if payload == "month":
        data = await state.get_data()
        year = data.get("year")
        if not year:
            await cb.message.answer("–û—à–∏–±–∫–∞: –≥–æ–¥ –Ω–µ –≤—ã–±—Ä–∞–Ω.", reply_markup=commander_menu)
            await cb.answer()
            await state.clear()
            return
        conn, cur = conn_cursor()
        cur.execute("""
            SELECT DISTINCT strftime('%m', date) as month
            FROM matches
            WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL AND strftime('%Y', date)=?
            ORDER BY month
        """, (user_id, user_id, year))
        rows = cur.fetchall()
        conn.close()
        months = [r[0] for r in rows if r and r[0]]
        if not months:
            await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –≤ —ç—Ç–æ–º –≥–æ–¥—É.", reply_markup=commander_menu)
            await cb.answer()
            await state.clear()
            return
        inline = InlineKeyboardMarkup(row_width=3)
        buttons = [InlineKeyboardButton(text=m, callback_data=f"hist_month:{m}") for m in months]
        buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:year"))
        inline.add(*buttons)
        await cb.message.answer(f"–í—ã–±—Ä–∞–Ω –≥–æ–¥ {year}. –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—è—Ü:", reply_markup=inline)
        await cb.answer()
        await state.set_state(HistoryStates.choosing_month)
        return

    await cb.answer()

# ---- –°—É–¥—å—è: –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ –º–∞—Ç—á–∏ (–¥–ª—è —Å—É–¥–µ–π) ----
@dp.message(F.text == "üìú –í—Å–µ –º–∞—Ç—á–∏")
async def all_matches(message: types.Message):
    user_id = message.from_user.id
    if not is_judge(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ –¥–ª—è —Å—É–¥–µ–π.")
        return
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time, result, server, map FROM matches ORDER BY date, time")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ü–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π.")
        return
    text_lines = []
    conn, cur = conn_cursor()
    for mid, t1, t2, d, tm, res, srv, mp in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        name1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        name2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        srv_text = f" | –°–µ—Ä–≤–µ—Ä: {srv}" if srv else ""
        map_text = f" | –ö–∞—Ä—Ç–∞: {mp}" if mp else ""
        text_lines.append(f"ID {mid}: {d} {tm}{srv_text}{map_text} ‚Äî {name1} vs {name2} | {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –∑–∞–¥–∞–Ω'}")
    conn.close()
    await message.answer("üìú –í—Å–µ –º–∞—Ç—á–∏:\n" + "\n".join(text_lines))

# ---- –°—É–¥—å—è: –≤—ã–±—Ä–∞—Ç—å –º–∞—Ç—á –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (inline) ----
@dp.message(F.text == "üìù –í–Ω–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç")
async def judge_choose_match_start(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if not is_judge(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ —Å—É–¥—å—è –º–æ–∂–µ—Ç –≤–Ω–æ—Å–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç.")
        return

    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time FROM matches WHERE result IS NULL ORDER BY date, time")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.")
        return

    inline_buttons = []
    for mid, t1, t2, d, tm in rows:
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        n2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        conn.close()
        inline_buttons.append([InlineKeyboardButton(text=f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2}", callback_data=f"judge_pick:{mid}")])

    kb = InlineKeyboardMarkup(inline_keyboard=inline_buttons)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á –¥–ª—è –≤–≤–æ–¥–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞:", reply_markup=kb)
    await state.set_state(JudgeStates.choosing_match)

@dp.callback_query(JudgeStates.choosing_match, F.data.startswith("judge_pick:"))
async def judge_pick_match(cb: types.CallbackQuery, state: FSMContext):
    mid = int(cb.data.split(":", 1)[1])
    await state.update_data(chosen_match_id=mid)
    await cb.message.answer(f"–í–≤–µ–¥–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –º–∞—Ç—á–∞ ID {mid} –≤ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ (–ø—Ä–∏–º–µ—Ä: 2-1 –∏–ª–∏ Team1 2:1 Team2):")
    await cb.answer()
    await state.set_state(JudgeStates.entering_result)

@dp.message(JudgeStates.entering_result, F.text)
async def judge_save_result(message: types.Message, state: FSMContext):
    data = await state.get_data()
    mid = data.get("chosen_match_id")
    if not mid:
        await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: –º–∞—Ç—á –Ω–µ –≤—ã–±—Ä–∞–Ω. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏—é.")
        await state.clear()
        return
    result_text = message.text.strip()
    conn, cur = conn_cursor()
    cur.execute("UPDATE matches SET result=?, judge_id=? WHERE id=?", (result_text, message.from_user.id, mid))
    conn.commit()

    # —É–≤–µ–¥–æ–º–∏—Ç—å –∫–æ–º–∞–Ω–¥—ã
    cur.execute("SELECT team1_id, team2_id, date, time FROM matches WHERE id=?", (mid,))
    row = cur.fetchone()
    if row:
        team1_id, team2_id, d, tm = row
        # –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –õ–°, –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ
        await send_safe(team1_id, f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ ID {mid}: {result_text} ({d} {tm})")
        if team2_id:
            await send_safe(team2_id, f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ ID {mid}: {result_text} ({d} {tm})")
        # group notify
        if GROUP_CHAT_ID:
            try:
                await bot.send_message(GROUP_CHAT_ID, f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ ID {mid}: {result_text} ({d} {tm})")
            except Exception as e:
                logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å group notify: %s", e)

    conn.close()
    await message.answer(f"‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –º–∞—Ç—á–∞ ID {mid} —Å–æ—Ö—Ä–∞–Ω—ë–Ω.")
    await state.clear()

# ---- –°—É–¥—å—è: —É–¥–∞–ª–∏—Ç—å –º–∞—Ç—á (inline selection) ----
@dp.message(F.text == "üóë –£–¥–∞–ª–∏—Ç—å –º–∞—Ç—á")
async def judge_delete_match_start(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if not is_judge(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ —Å—É–¥—å—è –º–æ–∂–µ—Ç —É–¥–∞–ª—è—Ç—å –º–∞—Ç—á–∏.")
        return

    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time FROM matches ORDER BY date, time")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return

    inline_buttons = []
    for mid, t1, t2, d, tm in rows:
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        n2 = r2[0] if r2 and r2[0] else f"ID {t2}" if t2 else "??"
        conn.close()
        inline_buttons.append([InlineKeyboardButton(text=f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2}", callback_data=f"del_match:{mid}")])

    kb = InlineKeyboardMarkup(inline_keyboard=inline_buttons)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=kb)
    await state.set_state(DeleteStates.choosing_delete_match)

@dp.callback_query(DeleteStates.choosing_delete_match, F.data.startswith("del_match:"))
async def judge_confirm_delete(cb: types.CallbackQuery, state: FSMContext):
    mid = int(cb.data.split(":", 1)[1])
    conn, cur = conn_cursor()
    cur.execute("SELECT team1_id, team2_id, date, time FROM matches WHERE id=?", (mid,))
    row = cur.fetchone()
    if not row:
        await cb.message.answer("–ú–∞—Ç—á –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        conn.close()
        await state.clear()
        await cb.answer()
        return
    t1, t2, d, tm = row
    # —É–¥–∞–ª—è–µ–º —Å–∞–º –º–∞—Ç—á
    cur.execute("DELETE FROM matches WHERE id=?", (mid,))
    # —É–¥–∞–ª—è–µ–º —Ç–∞–∫–∂–µ –∑–∞—è–≤–∫–∏ –æ–±–µ–∏—Ö –∫–æ–º–∞–Ω–¥ –Ω–∞ —ç—Ç—É –¥–∞—Ç—É/–≤—Ä–µ–º—è (–µ—Å–ª–∏ –µ—Å—Ç—å)
    try:
        cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (t1, d, tm))
        cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (t2, d, tm))
    except Exception as e:
        logger.info("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞—è–≤–æ–∫: %s", e)
    conn.commit()
    conn.close()

    # —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    await cb.message.answer(f"–ú–∞—Ç—á ID {mid} —É–¥–∞–ª—ë–Ω ‚úÖ (–º–∞—Ç—á –∏ –∑–∞—è–≤–∫–∏ —É–¥–∞–ª–µ–Ω—ã)")
    await send_safe(t1, f"‚ùå –ú–∞—Ç—á ID {mid} –±—ã–ª —É–¥–∞–ª—ë–Ω —Å—É–¥—å—ë–π ({d} {tm}). –í–∞—à–∏ –∑–∞—è–≤–∫–∏ –Ω–∞ {d} {tm} —Ç–∞–∫–∂–µ —É–¥–∞–ª–µ–Ω—ã.")
    if t2:
        await send_safe(t2, f"‚ùå –ú–∞—Ç—á ID {mid} –±—ã–ª —É–¥–∞–ª—ë–Ω —Å—É–¥—å—ë–π ({d} {tm}). –í–∞—à–∏ –∑–∞—è–≤–∫–∏ –Ω–∞ {d} {tm} —Ç–∞–∫–∂–µ —É–¥–∞–ª–µ–Ω—ã.")
    if GROUP_CHAT_ID:
        try:
            await bot.send_message(GROUP_CHAT_ID, f"‚ùå –ú–∞—Ç—á ID {mid} –±—ã–ª —É–¥–∞–ª—ë–Ω —Å—É–¥—å—ë–π ({d} {tm}).")
        except Exception:
            pass

    await state.clear()
    await cb.answer()

# --------------- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ "üîô –ù–∞–∑–∞–¥" ---------------
@dp.message(F.text == "üîô –ù–∞–∑–∞–¥")
async def back_to_menu(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if is_commander(user_id):
        await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é –∫–æ–º–∞–Ω–¥–∏—Ä–∞:", reply_markup=commander_menu)
    elif is_judge(user_id):
        await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é —Å—É–¥—å–∏:", reply_markup=judge_menu)
    else:
        await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=role_kb)
    await state.clear()

# --- –°—É–¥–µ–π—Å–∫–∞—è –∏—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π (–≥–æ–¥ -> –º–µ—Å—è—Ü -> –¥–µ–Ω—å): –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –í–°–ï –º–∞—Ç—á–∏ (—Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã) ---
async def judge_history_start(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    # –ü–æ—à–∞–≥–æ–≤—ã–π –≤—ã–±–æ—Ä –¥–ª—è —Å—É–¥–µ–π: –≥–æ–¥—ã, –º–µ—Å—è—Ü—ã, –¥–Ω–∏ ‚Äî –ø–æ –≤—Å–µ–º –º–∞—Ç—á–∞–º —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
    conn, cur = conn_cursor()
    cur.execute("""
        SELECT DISTINCT strftime('%Y', date) as year
        FROM matches
        WHERE result IS NOT NULL
        ORDER BY year DESC
    """)
    rows = cur.fetchall()
    conn.close()
    years = [r[0] for r in rows if r and r[0]]
    if not years:
        await message.answer("–ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π –ø—É—Å—Ç–∞.", reply_markup=judge_menu)
        return
    inline = InlineKeyboardMarkup(row_width=3)
    buttons = [InlineKeyboardButton(text=y, callback_data=f"jhist_year:{y}") for y in years]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="jhist_back:menu"))
    inline.add(*buttons)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–¥ (—Å—É–¥—å—è):", reply_markup=inline)
    await state.set_state(HistoryStates.choosing_year)

@dp.callback_query(F.data.startswith("jhist_year:"))
async def jhist_year_chosen(cb: types.CallbackQuery, state: FSMContext):
    year = cb.data.split(":", 1)[1]
    await state.update_data(j_year=year)

    conn, cur = conn_cursor()
    cur.execute("""
        SELECT DISTINCT strftime('%m', date) as month
        FROM matches
        WHERE result IS NOT NULL AND strftime('%Y', date)=?
        ORDER BY month
    """, (year,))
    rows = cur.fetchall()
    conn.close()
    months = [r[0] for r in rows if r and r[0]]
    if not months:
        await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –≤ —ç—Ç–æ–º –≥–æ–¥—É.", reply_markup=judge_menu)
        await cb.answer()
        await state.clear()
        return

    inline = InlineKeyboardMarkup(row_width=4)
    buttons = [InlineKeyboardButton(text=m, callback_data=f"jhist_month:{m}") for m in months]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="jhist_back:menu"))
    inline.add(*buttons)
    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω –≥–æ–¥ {year}. –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—è—Ü:", reply_markup=inline)
    await cb.answer()
    await state.set_state(HistoryStates.choosing_month)

@dp.callback_query(F.data.startswith("jhist_month:"))
async def jhist_month_chosen(cb: types.CallbackQuery, state: FSMContext):
    month = cb.data.split(":", 1)[1]
    await state.update_data(j_month=month)
    data = await state.get_data()
    year = data.get("j_year")
    conn, cur = conn_cursor()
    cur.execute("""
         SELECT DISTINCT strftime('%d', date) as day
         FROM matches
         WHERE result IS NOT NULL AND strftime('%Y', date)=? AND strftime('%m', date)=?
         ORDER BY day
    """, (year, month))
    rows = cur.fetchall()
    conn.close()
    days = [r[0] for r in rows if r and r[0]]
    if not days:
        await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –≤ —ç—Ç–æ–º –º–µ—Å—è—Ü–µ.", reply_markup=judge_menu)
        await cb.answer()
        await state.clear()
        return

    inline = InlineKeyboardMarkup(row_width=6)
    buttons = [InlineKeyboardButton(text=d, callback_data=f"jhist_day:{d}") for d in days]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="jhist_back:year"))
    inline.add(*buttons)
    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω {year}-{month}. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å:", reply_markup=inline)
    await cb.answer()
    await state.set_state(HistoryStates.choosing_day)

@dp.callback_query(F.data.startswith("jhist_day:"))
async def jhist_day_chosen(cb: types.CallbackQuery, state: FSMContext):
    day = cb.data.split(":", 1)[1]
    data = await state.get_data()
    year = data.get("j_year")
    month = data.get("j_month")
    if not (year and month):
        await cb.message.answer("–û—à–∏–±–∫–∞: –≥–æ–¥ –∏–ª–∏ –º–µ—Å—è—Ü –Ω–µ –≤—ã–±—Ä–∞–Ω—ã.", reply_markup=judge_menu)
        await cb.answer()
        await state.clear()
        return

    y = str(year)
    m = month.zfill(2)
    d = day.zfill(2)
    date_iso = f"{y}-{m}-{d}"

    conn, cur = conn_cursor()
    cur.execute("""
        SELECT id, team1_id, team2_id, time, result, server, map
        FROM matches
        WHERE date=? AND result IS NOT NULL
        ORDER BY time
    """, (date_iso,))
    rows = cur.fetchall()
    conn.close()

    if not rows:
        await cb.message.answer(f"–ù–µ—Ç —Å—ã–≥—Ä–∞–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π –∑–∞ {date_iso}.", reply_markup=judge_menu)
        await cb.answer()
        await state.clear()
        return

    lines = []
    conn, cur = conn_cursor()
    for mid, t1, t2, tm, res, srv, mp in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        name1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        name2 = r2[0] if r2 and r2[0] else (f"ID {t2}" if t2 else "??")
        srv_text = f" | –°–µ—Ä–≤–µ—Ä: {srv}" if srv else ""
        map_text = f" | –ö–∞—Ä—Ç–∞: {mp}" if mp else ""
        lines.append(f"ID {mid}: {tm} ‚Äî {name1} vs {name2}{srv_text}{map_text} | {res}")
    conn.close()

    await cb.message.answer(f"üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π (–≤—Å–µ –∫–æ–º–∞–Ω–¥—ã) –∑–∞ {date_iso}:\n" + "\n".join(lines), reply_markup=judge_menu)
    await cb.answer()
    await state.clear()

@dp.callback_query(F.data.startswith("jhist_back:"))
async def jhist_back(cb: types.CallbackQuery, state: FSMContext):
    payload = cb.data.split(":", 1)[1]
    if payload == "menu":
        await cb.message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é —Å—É–¥—å–∏:", reply_markup=judge_menu)
        await cb.answer()
        await state.clear()
        return
    if payload == "year":
        conn, cur = conn_cursor()
        cur.execute("""
            SELECT DISTINCT strftime('%Y', date) as year
            FROM matches
            WHERE result IS NOT NULL
            ORDER BY year DESC
        """)
        rows = cur.fetchall()
        conn.close()
        years = [r[0] for r in rows if r and r[0]]
        if not years:
            await cb.message.answer("–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.", reply_markup=judge_menu)
            await cb.answer()
            await state.clear()
            return
        inline = InlineKeyboardMarkup(row_width=3)
        buttons = [InlineKeyboardButton(text=y, callback_data=f"jhist_year:{y}") for y in years]
        buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="jhist_back:menu"))
        inline.add(*buttons)
        await cb.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–¥ (—Å—É–¥—å—è):", reply_markup=inline)
        await cb.answer()
        await state.set_state(HistoryStates.choosing_year)
        return
    await cb.answer()

# --------------- –ó–∞–ø—É—Å–∫ ---------------
async def main():
    logger.info("–£–¥–∞–ª—è–µ–º webhook (–µ—Å–ª–∏ –µ—Å—Ç—å) –∏ –∑–∞–ø—É—Å–∫–∞–µ–º polling")
    try:
        await bot.delete_webhook(drop_pending_updates=True)
    except Exception as e:
        logger.info("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ webhook: %s", e)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
