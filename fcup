#!/usr/bin/env python3
# fcup - squad tournament bot (aiogram 3.x)

import asyncio
import logging
import sqlite3
from datetime import date, timedelta

from aiogram import Bot, Dispatcher, F, types
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import Command
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton,
    InlineKeyboardMarkup, InlineKeyboardButton
)
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State

# ---------------- CONFIG ----------------
API_TOKEN = "8392821328:AAHHINFxwpSZKGRcv0vQXogGc-pnXcAZspI"

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --------------- DB ---------------------
conn = sqlite3.connect("tournament.db", check_same_thread=False)
cursor = conn.cursor()

cursor.execute("""
CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    phone TEXT,
    role TEXT,
    team_name TEXT
)
""")

cursor.execute("""
CREATE TABLE IF NOT EXISTS match_requests (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team_id INTEGER,
    date TEXT,
    time TEXT
)
""")

cursor.execute("""
CREATE TABLE IF NOT EXISTS matches (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team1_id INTEGER,
    team2_id INTEGER,
    date TEXT,
    time TEXT,
    result TEXT,
    judge_id INTEGER
)
""")
conn.commit()

# ------------- FSM states ---------------
class RegStates(StatesGroup):
    choosing_role = State()
    waiting_for_phone = State()
    waiting_for_team_name = State()

class ScheduleStates(StatesGroup):
    choosing_date = State()
    choosing_time = State()

class JudgeStates(StatesGroup):
    entering_result = State()

# ------------- Bot init -----------------
bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher(storage=MemoryStorage())

# ------------- Keyboards ----------------
role_kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä"), KeyboardButton(text="‚öñÔ∏è –Ø - —Å—É–¥—å—è")]
    ],
    resize_keyboard=True
)

contact_kb = ReplyKeyboardMarkup(
    keyboard=[[KeyboardButton(text="üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º", request_contact=True)]],
    resize_keyboard=True,
    one_time_keyboard=True
)

commander_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É")],
        [KeyboardButton(text="üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")],
        [KeyboardButton(text="üìú –ú–æ–∏ –º–∞—Ç—á–∏")]
    ],
    resize_keyboard=True
)

judge_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìù –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç")],
        [KeyboardButton(text="üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É")],
        [KeyboardButton(text="üìú –í—Å–µ –º–∞—Ç—á–∏")]
    ],
    resize_keyboard=True
)

# ------------- Helpers ------------------
def dates_next_week():
    today = date.today()
    return [(today + timedelta(days=i)).isoformat() for i in range(7)]

def send_safe(user_id: int, text: str):
    async def _send():
        try:
            await bot.send_message(user_id, text)
        except Exception as e:
            logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ %s: %s", user_id, e)
    asyncio.create_task(_send())

def has_match(team_id: int, date_iso: str, time_val: str) -> bool:
    cursor.execute("SELECT 1 FROM matches WHERE (team1_id=? OR team2_id=?) AND date=? AND time=?",
                   (team_id, team_id, date_iso, time_val))
    return cursor.fetchone() is not None

# ------------- Handlers -----------------
@dp.message(Command("start"))
async def cmd_start(message: types.Message, state: FSMContext):
    cursor.execute("SELECT role, team_name FROM users WHERE user_id = ?", (message.from_user.id,))
    r = cursor.fetchone()
    if r:
        role = r[0]
        if role == "commander":
            await message.answer("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä.", reply_markup=commander_menu)
        else:
            await message.answer("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è.", reply_markup=judge_menu)
        return

    await message.answer("–ü—Ä–∏–≤–µ—Ç! –í—ã–±–µ—Ä–∏ —Ä–æ–ª—å:", reply_markup=role_kb)
    await state.set_state(RegStates.choosing_role)

# --- –í—ã–±–æ—Ä —Ä–æ–ª–∏ ---
@dp.message(RegStates.choosing_role, F.text.in_(["üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä", "‚öñÔ∏è –Ø - —Å—É–¥—å—è"]))
async def choose_role(message: types.Message, state: FSMContext):
    role = "commander" if message.text == "üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä" else "judge"
    await state.update_data(chosen_role=role)
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞:", reply_markup=contact_kb)
    await state.set_state(RegStates.waiting_for_phone)

# --- –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–∞–∫—Ç–∞ ---
@dp.message(RegStates.waiting_for_phone, F.content_type == types.ContentType.CONTACT)
async def got_contact(message: types.Message, state: FSMContext):
    phone = message.contact.phone_number
    data = await state.get_data()
    role = data.get("chosen_role")
    user_id = message.from_user.id

    cursor.execute("INSERT OR REPLACE INTO users (user_id, phone, role) VALUES (?, ?, ?)", (user_id, phone, role))
    conn.commit()

    if role == "commander":
        await message.answer("–û—Ç–ª–∏—á–Ω–æ. –í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã (–æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ):", reply_markup=types.ReplyKeyboardRemove())
        await state.set_state(RegStates.waiting_for_team_name)
    else:
        await message.answer("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è ‚úÖ", reply_markup=judge_menu)
        await state.clear()

# --- –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã ---
@dp.message(RegStates.waiting_for_team_name, F.text)
async def got_team_name(message: types.Message, state: FSMContext):
    team_name = message.text.strip()
    if not team_name:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ –µ—â—ë —Ä–∞–∑.")
        return

    user_id = message.from_user.id
    cursor.execute("UPDATE users SET team_name = ? WHERE user_id = ?", (team_name, user_id))
    conn.commit()

    await message.answer(f"–ö–æ–º–∞–Ω–¥–∞ <b>{team_name}</b> –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞ ‚úÖ", reply_markup=commander_menu)
    await state.clear()

# --- –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É (–∫–æ–º–∞–Ω–¥–∏—Ä) ---
@dp.message(F.text == "üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É")
async def start_schedule(message: types.Message, state: FSMContext):
    cursor.execute("SELECT role, team_name FROM users WHERE user_id = ?", (message.from_user.id,))
    row = cursor.fetchone()
    if not row or row[0] != "commander" or not row[1]:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä –∏ —É–∫–∞–∂–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã.")
        return

    dates = dates_next_week()
    inline_buttons = []
    for d in dates:
        inline_buttons.append([InlineKeyboardButton(text=d, callback_data=f"slot_date:{d}")])
    kb = InlineKeyboardMarkup(inline_keyboard=inline_buttons)

    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π):", reply_markup=kb)
    await state.set_state(ScheduleStates.choosing_date)

@dp.callback_query(F.data.startswith("slot_date:"))
async def on_date_chosen(cb: types.CallbackQuery, state: FSMContext):
    _, date_iso = cb.data.split(":", 1)
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="19:00", callback_data=f"slot_time:{date_iso}|19:00")],
        [InlineKeyboardButton(text="20:00", callback_data=f"slot_time:{date_iso}|20:00")],
        [InlineKeyboardButton(text="21:00", callback_data=f"slot_time:{date_iso}|21:00")]
    ])
    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω–∞ –¥–∞—Ç–∞ {date_iso}. –í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è:", reply_markup=kb)
    await cb.answer()
    await state.update_data(chosen_date=date_iso)

@dp.callback_query(F.data.startswith("slot_time:"))
async def on_time_chosen(cb: types.CallbackQuery, state: FSMContext):
    _, payload = cb.data.split(":", 1)
    date_iso, time_val = payload.split("|")
    user_id = cb.from_user.id

    # –ü—Ä–æ–≤–µ—Ä–∫–∞: —É –∫–æ–º–∞–Ω–¥—ã —É–∂–µ –µ—Å—Ç—å –º–∞—Ç—á –≤ —ç—Ç–æ –≤—Ä–µ–º—è?
    if has_match(user_id, date_iso, time_val):
        await cb.message.answer("–£ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã —É–∂–µ –Ω–∞–∑–Ω–∞—á–µ–Ω –º–∞—Ç—á –Ω–∞ —ç—Ç—É –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è.")
        await cb.answer()
        return

    # –ü—Ä–æ–≤–µ—Ä–∫–∞: —É –∫–æ–º–∞–Ω–¥—ã —É–∂–µ –µ—Å—Ç—å –∑–∞—è–≤–∫–∞ –Ω–∞ —ç—Ç–æ –≤—Ä–µ–º—è?
    cursor.execute("SELECT id FROM match_requests WHERE team_id=? AND date=? AND time=?", (user_id, date_iso, time_val))
    if cursor.fetchone():
        await cb.message.answer("–£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –∑–∞—è–≤–∫–∞ –Ω–∞ —ç—Ç—É –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è.")
        await cb.answer()
        return

    cursor.execute("INSERT INTO match_requests (team_id, date, time) VALUES (?, ?, ?)", (user_id, date_iso, time_val))
    conn.commit()

    # –ü–æ–∏—Å–∫ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞
    cursor.execute("SELECT id, team_id FROM match_requests WHERE date=? AND time=? AND team_id!=?", (date_iso, time_val, user_id))
    opponents = cursor.fetchall()
    opponent = None
    for opp in opponents:
        if not has_match(opp[1], date_iso, time_val):
            opponent = opp
            break

    if opponent:
        opp_team_id = opponent[1]
        cursor.execute("INSERT INTO matches (team1_id, team2_id, date, time) VALUES (?, ?, ?, ?)", (user_id, opp_team_id, date_iso, time_val))
        match_id = cursor.lastrowid
        conn.commit()

        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
        t1 = cursor.fetchone()[0]
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (opp_team_id,))
        t2 = cursor.fetchone()[0]

        await cb.message.answer(f"–ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω –Ω–∞ {date_iso} {time_val}: <b>{t1}</b> vs <b>{t2}</b> (ID {match_id})")
        send_safe(opp_team_id, f"–ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω –Ω–∞ {date_iso} {time_val}: <b>{t1}</b> vs <b>{t2}</b> (ID {match_id})")
    else:
        await cb.message.answer(f"–ó–∞—è–≤–∫–∞ –Ω–∞ {date_iso} {time_val} —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞. –û–∂–∏–¥–∞–µ–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞...")

    await cb.answer()
    await state.clear()

# --- –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ ---
@dp.message(F.text == "üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
async def my_schedule(message: types.Message):
    user_id = message.from_user.id
    cursor.execute("SELECT id, date, time, result FROM matches WHERE team1_id=? OR team2_id=?", (user_id, user_id))
    rows = cursor.fetchall()
    if not rows:
        await message.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –º–∞—Ç—á–µ–π.")
        return

    lines = []
    for mid, d, t, r in rows:
        res = r if r else "–µ—â—ë –Ω–µ—Ç"
        lines.append(f"ID {mid}: {d} {t} ‚Äî —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {res}")
    await message.answer("\n".join(lines))

# --- –ú–æ–∏ –º–∞—Ç—á–∏ (—Ç–æ–ª—å–∫–æ –∫–æ–º–∞–Ω–¥–∏—Ä) ---
@dp.message(F.text == "üìú –ú–æ–∏ –º–∞—Ç—á–∏")
async def commander_matches(message: types.Message):
    user_id = message.from_user.id
    cursor.execute("SELECT role FROM users WHERE user_id=?", (user_id,))
    r = cursor.fetchone()
    if not r or r[0] != "commander":
        await message.answer("–¢–æ–ª—å–∫–æ –¥–ª—è –∫–æ–º–∞–Ω–¥–∏—Ä–æ–≤.")
        return

    cursor.execute("SELECT id, team1_id, team2_id, date, time, result FROM matches WHERE team1_id=? OR team2_id=?", (user_id, user_id))
    rows = cursor.fetchall()
    if not rows:
        await message.answer("–£ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã –ø–æ–∫–∞ –Ω–µ—Ç –º–∞—Ç—á–µ–π.")
        return

    lines = []
    for mid, t1, t2, d, tm, res in rows:
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        tn1 = cursor.fetchone()[0]
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        tn2 = cursor.fetchone()[0]
        res_txt = res if res else "–µ—â—ë –Ω–µ—Ç"
        lines.append(f"ID {mid}: {d} {tm} ‚Äî {tn1} vs {tn2}, —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {res_txt}")
    await message.answer("\n".join(lines))

# --- –í—Å–µ –º–∞—Ç—á–∏ (–¥–ª—è —Å—É–¥—å–∏) ---
@dp.message(F.text == "üìú –í—Å–µ –º–∞—Ç—á–∏")
async def all_matches(message: types.Message):
    user_id = message.from_user.id
    cursor.execute("SELECT role FROM users WHERE user_id=?", (user_id,))
    r = cursor.fetchone()
    if not r or r[0] != "judge":
        await message.answer("–¢–æ–ª—å–∫–æ –¥–ª—è —Å—É–¥–µ–π.")
        return

    cursor.execute("SELECT id, team1_id, team2_id, date, time, result FROM matches")
    rows = cursor.fetchall()
    if not rows:
        await message.answer("–ü–æ–∫–∞ –Ω–µ—Ç –º–∞—Ç—á–µ–π.")
        return

    lines = []
    for mid, t1, t2, d, tm, res in rows:
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        tn1 = cursor.fetchone()[0]
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        tn2 = cursor.fetchone()[0]
        res_txt = res if res else "–µ—â—ë –Ω–µ—Ç"
        lines.append(f"ID {mid}: {d} {tm} ‚Äî {tn1} vs {tn2}, —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {res_txt}")
    await message.answer("\n".join(lines))

# --- –°—É–¥—å—è: –¥–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç ---
@dp.message(F.text == "üìù –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç")
async def judge_add_result(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    cursor.execute("SELECT role FROM users WHERE user_id=?", (user_id,))
    r = cursor.fetchone()
    if not r or r[0] != "judge":
        await message.answer("–¢–æ–ª—å–∫–æ –¥–ª—è —Å—É–¥–µ–π.")
        return
    await message.answer("–í–≤–µ–¥–∏—Ç–µ ID –º–∞—Ç—á–∞ –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n123; Team1 1:0 Team2")
    await state.set_state(JudgeStates.entering_result)

@dp.message(JudgeStates.entering_result, F.text)
async def save_result(message: types.Message, state: FSMContext):
    try:
        match_id_str, result = message.text.split(";", 1)
        match_id = int(match_id_str.strip())
    except Exception:
        await message.answer("–§–æ—Ä–º–∞—Ç –Ω–µ–≤–µ—Ä–Ω—ã–π. –ü—Ä–∏–º–µ—Ä: 123; Team1 1:0 Team2")
        return

    cursor.execute("UPDATE matches SET result=?, judge_id=? WHERE id=?", (result.strip(), message.from_user.id, match_id))
    conn.commit()
    await message.answer(f"–†–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –º–∞—Ç—á–∞ {match_id} —Å–æ—Ö—Ä–∞–Ω—ë–Ω ‚úÖ")
    await state.clear()

# --- –°—É–¥—å—è: —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É ---
@dp.message(F.text == "üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É")
async def judge_results(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD:")

@dp.message(F.text.regexp(r"\d{4}-\d{2}-\d{2}"))
async def results_by_date(message: types.Message):
    d = message.text.strip()
    cursor.execute("SELECT id, team1_id, team2_id, time, result FROM matches WHERE date=?", (d,))
    rows = cursor.fetchall()
    if not rows:
        await message.answer("–ú–∞—Ç—á–µ–π –Ω–∞ —ç—Ç—É –¥–∞—Ç—É –Ω–µ—Ç.")
        return
    lines = []
    for mid, t1, t2, tm, res in rows:
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        tn1 = cursor.fetchone()[0]
        cursor.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        tn2 = cursor.fetchone()[0]
        res_txt = res if res else "–µ—â—ë –Ω–µ—Ç"
        lines.append(f"ID {mid}: {tn1} vs {tn2} –≤ {tm}, —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {res_txt}")
    await message.answer("\n".join(lines))

# ------------- –ó–∞–ø—É—Å–∫ -------------
async def main():
    logger.info("Deleting webhook (if any) and starting polling")
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
