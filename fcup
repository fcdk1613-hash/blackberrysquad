#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
–ü–æ–ª–Ω—ã–π –±–æ—Ç —Ç—É—Ä–Ω–∏—Ä–∞ Squad (aiogram 3.x)
–°–æ–¥–µ—Ä–∂–∏—Ç:
- —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è (–∫–æ–º–∞–Ω–¥–∏—Ä/—Å—É–¥—å—è) –ø–æ –∫–æ–Ω—Ç–∞–∫—Ç—É (—Ç–µ–ª–µ—Ñ–æ–Ω)
- –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∞–¥–º–∏–Ω–∞–º–∏
- –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Ç—á–µ–π (–≤—ã–±–æ—Ä –¥–∞—Ç—ã: –±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π; –≤—Ä–µ–º—è 19/20/21)
- –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–¥–±–æ—Ä —Å–æ–ø–µ—Ä–Ω–∏–∫–∞, —Å–µ—Ä–≤–µ—Ä–æ–≤ (Server2..Server4) –∏ –∫–∞—Ä—Ç—ã (—Ä–∞–Ω–¥–æ–º)
- pending_confirmations, –µ—Å–ª–∏ —É –¥–≤—É—Ö –∫–æ–º–∞–Ω–¥ –Ω–µ—Å–∫–æ–ª—å–∫–æ –æ–±—â–∏—Ö —Å–ª–æ—Ç–æ–≤
- —Å—É–¥—å–∏: –≤–Ω–æ—Å—è—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç -> –º–∞—Ç—á –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –≤ history
- —Å—É–¥—å–∏: –º–æ–≥—É—Ç —É–¥–∞–ª—è—Ç—å –º–∞—Ç—á–∏
- –∏—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π (–≥–æ–¥->–º–µ—Å—è—Ü->–¥–µ–Ω—å)
- sqlite3 database tournament.db
"""

import asyncio
import logging
import sqlite3
import random
from datetime import date, timedelta, datetime
from typing import Optional, List, Tuple

from aiogram import Bot, Dispatcher, F, types
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import Command
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove,
    InlineKeyboardMarkup, InlineKeyboardButton
)
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State

# ----------------- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ -----------------
API_TOKEN = "PUT_YOUR_TOKEN_HERE"  # <--- –≤—Å—Ç–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω —Å—é–¥–∞
GROUP_CHAT_ID: Optional[int] = None  # –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏: -1001234567890
DB_PATH = "tournament.db"

# –ö–∞—Ä—Ç—ã –∏ —Å–µ—Ä–≤–µ—Ä–∞ (–∏—Å–∫–ª—é—á–∞–µ–º –ø–µ—Ä–≤—ã–π —Å–µ—Ä–≤–µ—Ä)
MAPS = ["Narva", "Mutaha", "Harju", "Fallujah", "BlackCoast", "Sanxian"]
SERVERS = ["Server2", "Server3", "Server4"]

# –°–ø–∏—Å–æ–∫ –∞–¥–º–∏–Ω–æ–≤ (–≤—Å—Ç–∞–≤—å—Ç–µ Telegram user_id –∞–¥–º–∏–Ω–æ–≤)
ADMINS = [123456789]  # <-- –∏–∑–º–µ–Ω–∏—Ç—å

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ----------------- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î -----------------
def init_db():
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()

    # users: user_id, phone, role ('commander'|'judge'), team_name, approved (0/1)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            phone TEXT,
            role TEXT,
            team_name TEXT,
            approved INTEGER DEFAULT 0
        )
    """)

    # match requests (–æ–∂–∏–¥–∞–Ω–∏–µ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS match_requests (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team_id INTEGER,
            date TEXT,
            time TEXT
        )
    """)

    # matches (–∞–∫—Ç–∏–≤–Ω—ã–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–µ –º–∞—Ç—á–∏)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS matches (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team1_id INTEGER,
            team2_id INTEGER,
            date TEXT,
            time TEXT,
            server TEXT,
            map TEXT,
            judge_id INTEGER,
            result TEXT
        )
    """)

    # history (—Å—ã–≥—Ä–∞–Ω–Ω—ã–µ –º–∞—Ç—á–∏)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS match_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team1_id INTEGER,
            team2_id INTEGER,
            date TEXT,
            time TEXT,
            server TEXT,
            map TEXT,
            judge_id INTEGER,
            result TEXT
        )
    """)

    # pending_confirmations: –µ—Å–ª–∏ —É –¥–≤—É—Ö –∫–æ–º–∞–Ω–¥ –Ω–µ—Å–∫–æ–ª—å–∫–æ –æ–±—â–∏—Ö —Å–ª–æ—Ç–æ–≤ -> –≤—ã–±—Ä–∞—Ç—å –æ–¥–Ω–æ –≤—Ä–µ–º—è
    cur.execute("""
        CREATE TABLE IF NOT EXISTS pending_confirmations (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team1_id INTEGER,
            team2_id INTEGER,
            date TEXT,
            times_csv TEXT,
            choice_team1 TEXT,
            choice_team2 TEXT
        )
    """)

    conn.commit()
    conn.close()

init_db()

# ----------------- FSM -----------------
class RegStates(StatesGroup):
    choosing_role = State()
    waiting_for_contact = State()
    waiting_for_team_name = State()

class ScheduleStates(StatesGroup):
    choosing_date = State()
    choosing_time = State()

class ConfirmStates(StatesGroup):
    waiting_confirm = State()

class JudgeStates(StatesGroup):
    choosing_match = State()
    entering_result = State()

class DeleteStates(StatesGroup):
    choosing_delete = State()

class HistoryStates(StatesGroup):
    choosing_year = State()
    choosing_month = State()
    choosing_day = State()

# ----------------- Bot & Dispatcher -----------------
bot = Bot(token=API_TOKEN)  # don't pass parse_mode to constructor in aiogram 3.x
dp = Dispatcher(storage=MemoryStorage())

# ----------------- Utilities -----------------
def conn_cursor():
    conn = sqlite3.connect(DB_PATH, check_same_thread=False)
    cur = conn.cursor()
    return conn, cur

def dates_next_week_iso() -> List[str]:
    today = date.today()
    return [(today + timedelta(days=i)).isoformat() for i in range(7)]

async def send_safe(user_id: int, text: str, **kwargs):
    try:
        await bot.send_message(user_id, text, **kwargs)
    except Exception as e:
        logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ %s: %s", user_id, e)

def user_team_name(user_id: int) -> Optional[str]:
    conn, cur = conn_cursor()
    cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return r[0] if r and r[0] else None

def get_user_role(user_id: int) -> Optional[str]:
    conn, cur = conn_cursor()
    cur.execute("SELECT role FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return r[0] if r and r[0] else None

def is_commander(user_id: int) -> bool:
    conn, cur = conn_cursor()
    cur.execute("SELECT role, approved FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return bool(r and r[0] == "commander" and r[1] == 1)

def is_judge(user_id: int) -> bool:
    conn, cur = conn_cursor()
    cur.execute("SELECT role, approved FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return bool(r and r[0] == "judge" and r[1] == 1)

def has_active_match(team_id: int, date_iso: str, time_val: str) -> bool:
    conn, cur = conn_cursor()
    cur.execute("SELECT 1 FROM matches WHERE (team1_id=? OR team2_id=?) AND date=? AND time=?", (team_id, team_id, date_iso, time_val))
    r = cur.fetchone()
    conn.close()
    return r is not None

def pick_free_server(date_iso: str, time_val: str) -> Optional[str]:
    """Return random free server from SERVERS at given date/time or None"""
    conn, cur = conn_cursor()
    cur.execute("SELECT server FROM matches WHERE date=? AND time=?", (date_iso, time_val))
    busy = [row[0] for row in cur.fetchall() if row and row[0]]
    conn.close()
    available = [s for s in SERVERS if s not in busy]
    return random.choice(available) if available else None

def make_map_choice() -> str:
    return random.choice(MAPS)

# ----------------- Keyboards -----------------
role_kb = ReplyKeyboardMarkup(
    keyboard=[[KeyboardButton(text="üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä"), KeyboardButton(text="‚öñÔ∏è –Ø - —Å—É–¥—å—è")]],
    resize_keyboard=True
)
contact_kb = ReplyKeyboardMarkup(
    keyboard=[[KeyboardButton(text="üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º", request_contact=True)]],
    resize_keyboard=True,
    one_time_keyboard=True
)
commander_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É"), KeyboardButton(text="üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")],
        [KeyboardButton(text="üìú –ú–æ–∏ –º–∞—Ç—á–∏"), KeyboardButton(text="üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π")]
    ],
    resize_keyboard=True
)
judge_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìù –í–Ω–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç"), KeyboardButton(text="üìú –í—Å–µ –º–∞—Ç—á–∏")],
        [KeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –º–∞—Ç—á"), KeyboardButton(text="üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π")]
    ],
    resize_keyboard=True
)
back_kb = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="üîô –ù–∞–∑–∞–¥")]], resize_keyboard=True)

# ----------------- Handlers -----------------
@dp.message(Command("start"))
async def cmd_start(message: types.Message, state: FSMContext):
    conn, cur = conn_cursor()
    cur.execute("SELECT role, team_name, approved FROM users WHERE user_id=?", (message.from_user.id,))
    r = cur.fetchone()
    conn.close()
    if r:
        role, team_name, approved = r
        if role == "commander":
            if approved == 1:
                await message.answer("–í—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä.", reply_markup=commander_menu)
            else:
                await message.answer("–í–∞—à–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–∂–∏–¥–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.", reply_markup=ReplyKeyboardRemove())
        elif role == "judge":
            if approved == 1:
                await message.answer("–í—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è.", reply_markup=judge_menu)
            else:
                await message.answer("–í–∞—à–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Å—É–¥—å–∏ –æ–∂–∏–¥–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.", reply_markup=ReplyKeyboardRemove())
        else:
            await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å:", reply_markup=role_kb)
            await state.set_state(RegStates.choosing_role)
    else:
        await message.answer("–ü—Ä–∏–≤–µ—Ç! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å:", reply_markup=role_kb)
        await state.set_state(RegStates.choosing_role)

# Registration role
@dp.message(RegStates.choosing_role, F.text.in_(["üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä", "‚öñÔ∏è –Ø - —Å—É–¥—å—è"]))
async def choose_role(message: types.Message, state: FSMContext):
    role = "commander" if message.text == "üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä" else "judge"
    await state.update_data(chosen_role=role)
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–∫–Ω–æ–ø–∫–∞):", reply_markup=contact_kb)
    await state.set_state(RegStates.waiting_for_contact)

@dp.message(RegStates.waiting_for_contact, F.content_type == types.ContentType.CONTACT)
async def got_contact(message: types.Message, state: FSMContext):
    contact = message.contact
    phone = contact.phone_number if contact else None
    data = await state.get_data()
    role = data.get("chosen_role")
    user_id = message.from_user.id

    conn, cur = conn_cursor()
    # –≤—Å—Ç–∞–≤–∏–º –∏–ª–∏ –æ–±–Ω–æ–≤–∏–º –∑–∞–ø–∏—Å—å; approved=0 (–æ–∂–∏–¥–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è)
    cur.execute("INSERT OR REPLACE INTO users (user_id, phone, role, team_name, approved) VALUES (?, ?, ?, COALESCE((SELECT team_name FROM users WHERE user_id=?), NULL), COALESCE((SELECT approved FROM users WHERE user_id=?), 0))",
                (user_id, phone, role, user_id, user_id))
    conn.commit()
    conn.close()

    # –µ—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∏—Ä ‚Äî –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã (–Ω–æ –∫–æ–º–∞–Ω–¥–∞ –±—É–¥–µ—Ç –æ–∂–∏–¥–∞—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞)
    if role == "commander":
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã (–æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ):", reply_markup=ReplyKeyboardRemove())
        await state.set_state(RegStates.waiting_for_team_name)
    else:
        # —Å—É–¥—å—è –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω, –Ω–æ –Ω—É–∂–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∞–¥–º–∏–Ω–æ–º
        await message.answer("–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∞. –û–∂–∏–¥–∞–π—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.", reply_markup=ReplyKeyboardRemove())
        # —É–≤–µ–¥–æ–º–∏–º –∞–¥–º–∏–Ω–æ–≤
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
        cur.close(); conn.close()
        for a in ADMINS:
            try:
                await bot.send_message(a, f"–ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é —Å—É–¥—å–∏:\nUserID: {user_id}\nPhone: {phone}\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É: /accept {user_id} –∏–ª–∏ /decline {user_id}")
            except Exception:
                pass
        await state.clear()

@dp.message(RegStates.waiting_for_team_name, F.text)
async def got_team_name(message: types.Message, state: FSMContext):
    team_name = message.text.strip()
    if not team_name:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ –µ—â—ë —Ä–∞–∑:")
        return
    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("UPDATE users SET team_name=? WHERE user_id=?", (team_name, user_id))
    conn.commit()
    conn.close()

    await message.answer(f"–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∫–æ–º–∞–Ω–¥—ã '{team_name}' –ø–æ–ª—É—á–µ–Ω–∞. –û–∂–∏–¥–∞–π—Ç–µ –æ–¥–æ–±—Ä–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.", reply_markup=ReplyKeyboardRemove())
    # —É–≤–µ–¥–æ–º–ª—è–µ–º –∞–¥–º–∏–Ω–æ–≤
    conn, cur = conn_cursor()
    cur.execute("SELECT phone FROM users WHERE user_id=?", (user_id,))
    phone = cur.fetchone()[0] if cur.fetchone() is None else None
    conn.close()
    for a in ADMINS:
        try:
            await bot.send_message(a, f"–ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∫–æ–º–∞–Ω–¥—ã:\nUserID: {user_id}\nTeam: {team_name}\n\n–ü—Ä–∏–Ω—è—Ç—å: /accept {user_id}\n–û—Ç–∫–ª–æ–Ω–∏—Ç—å: /decline {user_id}")
        except Exception:
            pass

    await state.clear()

# Admin accept/decline
@dp.message(Command("accept"))
async def admin_accept(message: types.Message):
    if message.from_user.id not in ADMINS:
        return
    parts = message.text.split()
    if len(parts) < 2:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /accept <user_id>")
        return
    try:
        uid = int(parts[1])
    except ValueError:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π user_id")
        return
    conn, cur = conn_cursor()
    cur.execute("UPDATE users SET approved=1 WHERE user_id=?", (uid,))
    conn.commit()
    cur.execute("SELECT role, team_name FROM users WHERE user_id=?", (uid,))
    r = cur.fetchone()
    conn.close()
    if r:
        role, team = r
        try:
            await bot.send_message(uid, f"–í–∞—à–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º. –†–æ–ª—å: {role}.")
        except Exception:
            pass
        await message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} –æ–¥–æ–±—Ä–µ–Ω.")
    else:
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")

@dp.message(Command("decline"))
async def admin_decline(message: types.Message):
    if message.from_user.id not in ADMINS:
        return
    parts = message.text.split()
    if len(parts) < 2:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /decline <user_id>")
        return
    try:
        uid = int(parts[1])
    except ValueError:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π user_id")
        return
    conn, cur = conn_cursor()
    cur.execute("DELETE FROM users WHERE user_id=?", (uid,))
    conn.commit()
    conn.close()
    try:
        await bot.send_message(uid, "–í–∞—à–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception:
        pass
    await message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} –æ—Ç–∫–ª–æ–Ω—ë–Ω –∏ —É–¥–∞–ª—ë–Ω.")

# Commander menu: start scheduling
@dp.message(F.text == "üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É")
async def start_schedule(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if not is_commander(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ –∫–æ–º–∞–Ω–¥–∏—Ä—ã –º–æ–≥—É—Ç –Ω–∞–∑–Ω–∞—á–∞—Ç—å –∏–≥—Ä—ã.")
        return
    dates = dates_next_week_iso()
    inline = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=d, callback_data=f"slot_date:{d}")] for d in dates])
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π):", reply_markup=inline)
    await state.set_state(ScheduleStates.choosing_date)

@dp.callback_query(F.data.startswith("slot_date:"))
async def on_date_chosen(cb: types.CallbackQuery, state: FSMContext):
    date_iso = cb.data.split(":", 1)[1]
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="19:00", callback_data=f"slot_time:{date_iso}|19:00")],
        [InlineKeyboardButton(text="20:00", callback_data=f"slot_time:{date_iso}|20:00")],
        [InlineKeyboardButton(text="21:00", callback_data=f"slot_time:{date_iso}|21:00")],
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="slot_back")]
    ])
    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω–∞ –¥–∞—Ç–∞ <b>{date_iso}</b>. –í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è:", parse_mode="HTML", reply_markup=kb)
    await cb.answer()
    await state.update_data(chosen_date=date_iso)
    await state.set_state(ScheduleStates.choosing_time)

@dp.callback_query(F.data == "slot_back")
async def slot_back(cb: types.CallbackQuery, state: FSMContext):
    dates = dates_next_week_iso()
    inline = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=d, callback_data=f"slot_date:{d}")] for d in dates])
    await cb.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π):", reply_markup=inline)
    await cb.answer()
    await state.set_state(ScheduleStates.choosing_date)

@dp.callback_query(F.data.startswith("slot_time:"))
async def on_time_chosen(cb: types.CallbackQuery, state: FSMContext):
    payload = cb.data.split(":", 1)[1]
    date_iso, time_val = payload.split("|", 1)
    user_id = cb.from_user.id

    # basic checks
    if not is_commander(user_id):
        await cb.message.answer("–¢–æ–ª—å–∫–æ –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ –∫–æ–º–∞–Ω–¥–∏—Ä—ã –º–æ–≥—É—Ç –Ω–∞–∑–Ω–∞—á–∞—Ç—å –∏–≥—Ä—ã.")
        await cb.answer()
        return

    if has_active_match(user_id, date_iso, time_val):
        await cb.message.answer("‚ùå –£ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã —É–∂–µ –µ—Å—Ç—å –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –º–∞—Ç—á –≤ —ç—Ç–æ—Ç —Å–ª–æ—Ç.")
        await cb.answer()
        await state.clear()
        return

    conn, cur = conn_cursor()
    # check duplicate request
    cur.execute("SELECT id FROM match_requests WHERE team_id=? AND date=? AND time=?", (user_id, date_iso, time_val))
    if cur.fetchone():
        conn.close()
        await cb.message.answer("–£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –∑–∞—è–≤–∫–∞ –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç ‚Äî –∂–¥—ë–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.")
        await cb.answer()
        await state.clear()
        return

    # insert request
    cur.execute("INSERT INTO match_requests (team_id, date, time) VALUES (?, ?, ?)", (user_id, date_iso, time_val))
    conn.commit()

    # find other teams with requests on the same date
    cur.execute("SELECT team_id, time FROM match_requests WHERE date=? AND team_id!=?", (date_iso, user_id))
    rows = cur.fetchall()
    # map team_id -> set(times)
    other_times = {}
    for tid, t in rows:
        other_times.setdefault(tid, set()).add(t)

    # get all times of this user on that date
    cur.execute("SELECT time FROM match_requests WHERE date=? AND team_id=?", (date_iso, user_id))
    my_times = {r[0] for r in cur.fetchall()}

    opponent_found = False
    for candidate_id, times_set in other_times.items():
        # skip if candidate already has active match at some of these times (safety)
        # we'll compute intersection
        common = sorted(list(my_times & times_set))
        if not common:
            continue

        # filter out times where candidate or user already have active matches
        filtered = []
        for t in common:
            if has_active_match(candidate_id, date_iso, t) or has_active_match(user_id, date_iso, t):
                continue
            filtered.append(t)
        if not filtered:
            continue

        # if exactly one common slot -> create match immediately
        if len(filtered) == 1:
            chosen_time = filtered[0]
            # pick server and map automatically
            server = pick_free_server(date_iso, chosen_time)
            if not server:
                # cannot schedule; notify both
                await send_safe(candidate_id, f"‚ö†Ô∏è –ü–æ–ø—ã—Ç–∫–∞ –Ω–∞–∑–Ω–∞—á–∏—Ç—å –º–∞—Ç—á –Ω–∞ {date_iso} {chosen_time}, –Ω–æ –≤—Å–µ —Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–Ω—è—Ç—ã.")
                await send_safe(user_id, f"‚ö†Ô∏è –ü–æ–ø—ã—Ç–∫–∞ –Ω–∞–∑–Ω–∞—á–∏—Ç—å –º–∞—Ç—á –Ω–∞ {date_iso} {chosen_time}, –Ω–æ –≤—Å–µ —Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–Ω—è—Ç—ã.")
                conn.close()
                await cb.answer()
                await state.clear()
                return

            chosen_map = make_map_choice()
            # insert into matches
            cur.execute("INSERT INTO matches (team1_id, team2_id, date, time, server, map) VALUES (?, ?, ?, ?, ?, ?)",
                        (candidate_id, user_id, date_iso, chosen_time, server, chosen_map))
            match_id = cur.lastrowid
            # delete both requests for that timeslot
            cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (candidate_id, date_iso, chosen_time))
            cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (user_id, date_iso, chosen_time))
            conn.commit()

            # notify teams
            cur.execute("SELECT team_name FROM users WHERE user_id=?", (candidate_id,))
            r1 = cur.fetchone(); name1 = r1[0] if r1 and r1[0] else f"ID {candidate_id}"
            cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
            r2 = cur.fetchone(); name2 = r2[0] if r2 and r2[0] else f"ID {user_id}"

            text = f"‚öîÔ∏è –ù–∞–∑–Ω–∞—á–µ–Ω –º–∞—Ç—á!\nID {match_id}\nüìÖ {date_iso} ‚è∞ {chosen_time}\nüèÜ {name1} vs {name2}\nüåê –°–µ—Ä–≤–µ—Ä: {server}\nüó∫ –ö–∞—Ä—Ç–∞: {chosen_map}"
            await send_safe(candidate_id, text)
            await send_safe(user_id, text)
            if GROUP_CHAT_ID:
                try:
                    await bot.send_message(GROUP_CHAT_ID, text)
                except Exception:
                    pass
            await cb.message.answer(f"–ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω: {name1} vs {name2} (ID {match_id})")
            await cb.answer()
            conn.close()
            opponent_found = True
            break

        # if multiple common slots -> create pending_confirmations row and ask both to pick a slot
        if len(filtered) > 1:
            times_csv = ",".join(filtered)
            cur.execute("INSERT INTO pending_confirmations (team1_id, team2_id, date, times_csv) VALUES (?, ?, ?, ?)",
                        (candidate_id, user_id, date_iso, times_csv))
            pc_id = cur.lastrowid
            conn.commit()

            buttons = [[InlineKeyboardButton(text=t, callback_data=f"confirm_time:{pc_id}:{t}")] for t in filtered]
            buttons.append([InlineKeyboardButton(text="‚ùå –û—Ç–∫–∞–∑–∞—Ç—å—Å—è", callback_data=f"confirm_time:{pc_id}:CANCEL")])
            kb = InlineKeyboardMarkup(inline_keyboard=buttons)

            cur.execute("SELECT team_name FROM users WHERE user_id=?", (candidate_id,))
            r1 = cur.fetchone(); name1 = r1[0] if r1 and r1[0] else f"ID {candidate_id}"
            cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
            r2 = cur.fetchone(); name2 = r2[0] if r2 and r2[0] else f"ID {user_id}"

            txt = (f"üîî –ù–∞–π–¥–µ–Ω —Å–æ–ø–µ—Ä–Ω–∏–∫: {name1} vs {name2}\nüìÖ {date_iso}\n"
                   f"–£ –≤–∞—Å –æ–±—â–∏–µ –≤—Ä–µ–º–µ–Ω–∞: {', '.join(filtered)}\n"
                   f"–û–±–∞ –¥–æ–ª–∂–Ω—ã –≤—ã–±—Ä–∞—Ç—å –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ –≤—Ä–µ–º—è –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –º–∞—Ç—á–∞.")
            await send_safe(candidate_id, txt)
            await send_safe(user_id, txt)
            try:
                await bot.send_message(candidate_id, "–í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è:", reply_markup=kb)
            except Exception:
                pass
            try:
                await bot.send_message(user_id, "–í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è:", reply_markup=kb)
            except Exception:
                pass

            conn.close()
            opponent_found = True
            break

    if not opponent_found:
        conn.close()
        await cb.message.answer(f"‚úÖ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –Ω–∞ {date_iso} {time_val}. –û–∂–∏–¥–∞–µ–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.")
        await cb.answer()
        await state.clear()
        return

    await cb.answer()
    await state.clear()

@dp.callback_query(F.data.startswith("confirm_time:"))
async def handle_confirm_time(cb: types.CallbackQuery):
    # callback_data: confirm_time:{pc_id}:{choice_or_CANCEL}
    payload = cb.data.split(":", 1)[1]
    try:
        pc_id_str, choice = payload.split(":", 1)
        pc_id = int(pc_id_str)
    except Exception:
        await cb.answer("–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.")
        return

    user_id = cb.from_user.id
    conn, cur = conn_cursor()
    cur.execute("SELECT team1_id, team2_id, date, times_csv, choice_team1, choice_team2 FROM pending_confirmations WHERE id=?", (pc_id,))
    row = cur.fetchone()
    if not row:
        conn.close()
        await cb.answer("–ó–∞–ø—Ä–æ—Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return
    t1, t2, date_iso, times_csv, c1, c2 = row
    times = times_csv.split(",") if times_csv else []

    if user_id != t1 and user_id != t2:
        conn.close()
        await cb.answer("–í—ã –Ω–µ —É—á–∞—Å—Ç–Ω–∏–∫ —ç—Ç–æ–≥–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
        return

    if choice == "CANCEL":
        cur.execute("DELETE FROM pending_confirmations WHERE id=?", (pc_id,))
        conn.commit()
        conn.close()
        await send_safe(t1, "‚ùå –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ. –ü–æ–∏—Å–∫ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è.")
        await send_safe(t2, "‚ùå –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ. –ü–æ–∏—Å–∫ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è.")
        await cb.answer("–í—ã –æ—Ç–º–µ–Ω–∏–ª–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ.")
        return

    if choice not in times:
        conn.close()
        await cb.answer("–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä –≤—Ä–µ–º–µ–Ω–∏.")
        return

    if user_id == t1:
        cur.execute("UPDATE pending_confirmations SET choice_team1=? WHERE id=?", (choice, pc_id))
    else:
        cur.execute("UPDATE pending_confirmations SET choice_team2=? WHERE id=?", (choice, pc_id))
    conn.commit()

    cur.execute("SELECT choice_team1, choice_team2 FROM pending_confirmations WHERE id=?", (pc_id,))
    ch = cur.fetchone()
    conn.close()
    choice1, choice2 = ch if ch else (None, None)

    await cb.answer("–í–∞—à –≤—ã–±–æ—Ä –ø—Ä–∏–Ω—è—Ç. –û–∂–∏–¥–∞–µ–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.")
    if choice1 and choice2:
        if choice1 == choice2:
            # both chose same -> create match
            conn, cur = conn_cursor()
            cur.execute("SELECT team1_id, team2_id, date FROM pending_confirmations WHERE id=?", (pc_id,))
            row2 = cur.fetchone()
            if not row2:
                conn.close()
                return
            t1id, t2id, date_iso = row2
            chosen_time = choice1
            server = pick_free_server(date_iso, chosen_time)
            if not server:
                cur.execute("DELETE FROM pending_confirmations WHERE id=?", (pc_id,))
                conn.commit()
                conn.close()
                await send_safe(t1id, f"‚ö†Ô∏è –í—Å–µ —Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–Ω—è—Ç—ã –Ω–∞ {date_iso} {chosen_time}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Å–ª–æ—Ç.")
                await send_safe(t2id, f"‚ö†Ô∏è –í—Å–µ —Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–Ω—è—Ç—ã –Ω–∞ {date_iso} {chosen_time}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Å–ª–æ—Ç.")
                return
            chosen_map = make_map_choice()
            cur.execute("INSERT INTO matches (team1_id, team2_id, date, time, server, map) VALUES (?, ?, ?, ?, ?, ?)",
                        (t1id, t2id, date_iso, chosen_time, server, chosen_map))
            match_id = cur.lastrowid
            # remove pending_confirmations and relevant requests
            cur.execute("DELETE FROM pending_confirmations WHERE id=?", (pc_id,))
            cur.execute("DELETE FROM match_requests WHERE team_id IN (?, ?) AND date=? AND time=?", (t1id, t2id, date_iso, chosen_time))
            conn.commit()
            # notify
            cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1id,))
            n1 = cur.fetchone(); n1s = n1[0] if n1 and n1[0] else f"ID {t1id}"
            cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2id,))
            n2 = cur.fetchone(); n2s = n2[0] if n2 and n2[0] else f"ID {t2id}"
            text = f"‚öîÔ∏è –ù–∞–∑–Ω–∞—á–µ–Ω –º–∞—Ç—á!\nID {match_id}\nüìÖ {date_iso} ‚è∞ {chosen_time}\nüèÜ {n1s} vs {n2s}\nüåê –°–µ—Ä–≤–µ—Ä: {server}\nüó∫ –ö–∞—Ä—Ç–∞: {chosen_map}"
            await send_safe(t1id, text)
            await send_safe(t2id, text)
            if GROUP_CHAT_ID:
                try:
                    await bot.send_message(GROUP_CHAT_ID, text)
                except Exception:
                    pass
            conn.close()
        else:
            # mismatch -> cancel and notify
            conn, cur = conn_cursor()
            cur.execute("SELECT team1_id, team2_id FROM pending_confirmations WHERE id=?", (pc_id,))
            pr = cur.fetchone()
            if pr:
                t1id, t2id = pr
                cur.execute("DELETE FROM pending_confirmations WHERE id=?", (pc_id,))
                conn.commit()
                conn.close()
                await send_safe(t1id, "‚õî –í—ã–±–æ—Ä –≤—Ä–µ–º–µ–Ω–∏ –Ω–µ —Å–æ–≤–ø–∞–ª. –ü–æ–∏—Å–∫ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è.")
                await send_safe(t2id, "‚õî –í—ã–±–æ—Ä –≤—Ä–µ–º–µ–Ω–∏ –Ω–µ —Å–æ–≤–ø–∞–ª. –ü–æ–∏—Å–∫ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è.")
            else:
                conn.close()

# Commander: view own requests
@dp.message(F.text == "üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
async def my_schedule(message: types.Message):
    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("SELECT date, time FROM match_requests WHERE team_id=?", (user_id,))
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞—è–≤–æ–∫.")
        return
    lines = [f"{d} {t}" for d, t in rows]
    await message.answer("üìÖ –í–∞—à–∏ –∑–∞—è–≤–∫–∏:\n" + "\n".join(lines))

# Commander: view active matches
@dp.message(F.text == "üìú –ú–æ–∏ –º–∞—Ç—á–∏")
async def my_matches(message: types.Message):
    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time, server, map, result FROM matches WHERE team1_id=? OR team2_id=? ORDER BY date, time", (user_id, user_id))
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–£ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã –ø–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π.")
        return
    text_lines = []
    conn, cur = conn_cursor()
    for mid, t1, t2, d, tm, srv, mp, res in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone(); n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone(); n2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        text_lines.append(f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2} | –°–µ—Ä–≤–µ—Ä: {srv} | –ö–∞—Ä—Ç–∞: {mp} | {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –∑–∞–¥–∞–Ω'}")
    conn.close()
    await message.answer("üìú –í–∞—à–∏ –º–∞—Ç—á–∏:\n" + "\n".join(text_lines))

# Commander: view history (uses match_history table) - implemented as year->month->day selection
@dp.message(F.text == "üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π")
async def history_start(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("SELECT DISTINCT strftime('%Y', date) FROM match_history WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL ORDER BY 1 DESC", (user_id, user_id))
    rows = cur.fetchall()
    conn.close()
    years = [r[0] for r in rows if r and r[0]]
    if not years:
        await message.answer("–ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π –ø—É—Å—Ç–∞.", reply_markup=commander_menu)
        return
    inline = InlineKeyboardMarkup(row_width=3)
    buttons = [InlineKeyboardButton(text=y, callback_data=f"hist_year:{y}") for y in years]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:menu"))
    inline.add(*buttons)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–¥:", reply_markup=inline)
    await state.set_state(HistoryStates.choosing_year)

@dp.callback_query(F.data.startswith("hist_year:"))
async def hist_year(cb: types.CallbackQuery, state: FSMContext):
    year = cb.data.split(":",1)[1]
    user_id = cb.from_user.id
    await state.update_data(year=year)
    conn, cur = conn_cursor()
    cur.execute("SELECT DISTINCT strftime('%m', date) FROM match_history WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL AND strftime('%Y', date)=? ORDER BY 1", (user_id, user_id, year))
    rows = cur.fetchall()
    conn.close()
    months = [r[0] for r in rows if r and r[0]]
    if not months:
        await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –≤ —ç—Ç–æ–º –≥–æ–¥—É.", reply_markup=commander_menu)
        await cb.answer()
        await state.clear()
        return
    inline = InlineKeyboardMarkup(row_width=4)
    buttons = [InlineKeyboardButton(text=m, callback_data=f"hist_month:{m}") for m in months]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:year"))
    inline.add(*buttons)
    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω –≥–æ–¥ {year}. –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—è—Ü:", reply_markup=inline)
    await cb.answer()
    await state.set_state(HistoryStates.choosing_month)

@dp.callback_query(F.data.startswith("hist_month:"))
async def hist_month(cb: types.CallbackQuery, state: FSMContext):
    month = cb.data.split(":",1)[1]
    user_id = cb.from_user.id
    data = await state.get_data()
    year = data.get("year")
    await state.update_data(month=month)
    conn, cur = conn_cursor()
    cur.execute("SELECT DISTINCT strftime('%d', date) FROM match_history WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL AND strftime('%Y', date)=? AND strftime('%m', date)=? ORDER BY 1", (user_id, user_id, year, month))
    rows = cur.fetchall()
    conn.close()
    days = [r[0] for r in rows if r and r[0]]
    if not days:
        await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –≤ —ç—Ç–æ–º –º–µ—Å—è—Ü–µ.", reply_markup=commander_menu)
        await cb.answer()
        await state.clear()
        return
    inline = InlineKeyboardMarkup(row_width=6)
    buttons = [InlineKeyboardButton(text=d, callback_data=f"hist_day:{d}") for d in days]
    buttons.append(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="hist_back:month"))
    inline.add(*buttons)
    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω {year}-{month}. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å:", reply_markup=inline)
    await cb.answer()
    await state.set_state(HistoryStates.choosing_day)

@dp.callback_query(F.data.startswith("hist_day:"))
async def hist_day(cb: types.CallbackQuery, state: FSMContext):
    day = cb.data.split(":",1)[1]
    data = await state.get_data()
    year = data.get("year"); month = data.get("month")
    user_id = cb.from_user.id
    date_iso = f"{year}-{month.zfill(2)}-{day.zfill(2)}"
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, time, server, map, result FROM match_history WHERE date=? AND (team1_id=? OR team2_id=?) ORDER BY time", (date_iso, user_id, user_id))
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await cb.message.answer("–ú–∞—Ç—á–µ–π –∑–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", reply_markup=commander_menu)
        await cb.answer()
        await state.clear()
        return
    lines = []
    conn, cur = conn_cursor()
    for mid, t1, t2, tm, srv, mp, res in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone(); n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone(); n2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        lines.append(f"ID {mid}: {tm} ‚Äî {n1} vs {n2} | –°–µ—Ä–≤–µ—Ä: {srv} | –ö–∞—Ä—Ç–∞: {mp} | {res}")
    conn.close()
    await cb.message.answer(f"üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π –∑–∞ {date_iso}:\n" + "\n".join(lines), reply_markup=commander_menu)
    await cb.answer()
    await state.clear()

@dp.callback_query(F.data.startswith("hist_back:"))
async def hist_back(cb: types.CallbackQuery, state: FSMContext):
    payload = cb.data.split(":",1)[1]
    user_id = cb.from_user.id
    if payload == "menu":
        if is_commander(user_id):
            await cb.message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é:", reply_markup=commander_menu)
        else:
            await cb.message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é:", reply_markup=role_kb)
        await cb.answer()
        await state.clear()
        return
    if payload == "year":
        await hist_year(cb, state)
    if payload == "month":
        await hist_month(cb, state)

# ----------------- Judge: list all active matches -----------------
@dp.message(F.text == "üìú –í—Å–µ –º–∞—Ç—á–∏")
async def all_matches(message: types.Message):
    user_id = message.from_user.id
    if not is_judge(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ —Å—É–¥—å–∏ –º–æ–≥—É—Ç –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –≤—Å–µ –º–∞—Ç—á–∏.")
        return
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time, server, map, result FROM matches ORDER BY date, time")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ü–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π.")
        return
    lines = []
    conn, cur = conn_cursor()
    for mid, t1, t2, d, tm, srv, mp, res in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone(); n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone(); n2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        lines.append(f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2} | –°–µ—Ä–≤–µ—Ä: {srv} | –ö–∞—Ä—Ç–∞: {mp} | {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –∑–∞–¥–∞–Ω'}")
    conn.close()
    await message.answer("üìú –í—Å–µ –º–∞—Ç—á–∏:\n" + "\n".join(lines))

# Judge: choose match to enter result
@dp.message(F.text == "üìù –í–Ω–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç")
async def judge_choose_match_start(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if not is_judge(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ —Å—É–¥—å—è –º–æ–∂–µ—Ç –≤–Ω–æ—Å–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç.")
        return
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time FROM matches WHERE result IS NULL ORDER BY date, time")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.")
        return
    inline = InlineKeyboardMarkup()
    for mid, t1, t2, d, tm in rows:
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone(); n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone(); n2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        conn.close()
        inline.add(InlineKeyboardButton(text=f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2}", callback_data=f"judge_pick:{mid}"))
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á –¥–ª—è –≤–≤–æ–¥–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞:", reply_markup=inline)
    await state.set_state(JudgeStates.choosing_match)

@dp.callback_query(JudgeStates.choosing_match, F.data.startswith("judge_pick:"))
async def judge_pick_match(cb: types.CallbackQuery, state: FSMContext):
    mid = int(cb.data.split(":",1)[1])
    await state.update_data(chosen_match_id=mid)
    await cb.message.answer(f"–í–≤–µ–¥–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –º–∞—Ç—á–∞ ID {mid} (–ø—Ä–∏–º–µ—Ä: 2-1 –∏–ª–∏ TeamA 2:1 TeamB):")
    await cb.answer()
    await state.set_state(JudgeStates.entering_result)

@dp.message(JudgeStates.entering_result, F.text)
async def judge_save_result(message: types.Message, state: FSMContext):
    data = await state.get_data()
    mid = data.get("chosen_match_id")
    if not mid:
        await message.answer("–û—à–∏–±–∫–∞: –º–∞—Ç—á –Ω–µ –≤—ã–±—Ä–∞–Ω.")
        await state.clear()
        return
    result_text = message.text.strip()

    conn, cur = conn_cursor()
    # get match info
    cur.execute("SELECT team1_id, team2_id, date, time, server, map FROM matches WHERE id=?", (mid,))
    row = cur.fetchone()
    if not row:
        await message.answer("–ú–∞—Ç—á –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        conn.close()
        await state.clear()
        return
    t1, t2, d, tm, srv, mp = row

    # insert into history
    cur.execute("INSERT INTO match_history (team1_id, team2_id, date, time, server, map, judge_id, result) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                (t1, t2, d, tm, srv, mp, message.from_user.id, result_text))
    # delete from matches
    cur.execute("DELETE FROM matches WHERE id=?", (mid,))
    conn.commit()
    conn.close()

    # notify teams
    await send_safe(t1, f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ ID {mid}: {result_text} ({d} {tm})")
    if t2:
        await send_safe(t2, f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ ID {mid}: {result_text} ({d} {tm})")
    if GROUP_CHAT_ID:
        try:
            await bot.send_message(GROUP_CHAT_ID, f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ ID {mid}: {result_text} ({d} {tm})")
        except Exception:
            pass

    await message.answer(f"‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –º–∞—Ç—á–∞ ID {mid} —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∏ –º–∞—Ç—á –ø–µ—Ä–µ–Ω–µ—Å—ë–Ω –≤ –∏—Å—Ç–æ—Ä–∏—é.")
    await state.clear()

# Judge: delete match
@dp.message(F.text == "üóë –£–¥–∞–ª–∏—Ç—å –º–∞—Ç—á")
async def judge_delete_match_start(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if not is_judge(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ —Å—É–¥—å—è –º–æ–∂–µ—Ç —É–¥–∞–ª—è—Ç—å –º–∞—Ç—á–∏.")
        return
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time, server, map FROM matches ORDER BY date, time")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return
    inline = InlineKeyboardMarkup()
    for mid, t1, t2, d, tm, srv, mp in rows:
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone(); n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone(); n2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        conn.close()
        inline.add(InlineKeyboardButton(text=f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2}", callback_data=f"del_match:{mid}"))
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=inline)
    await state.set_state(DeleteStates.choosing_delete)

@dp.callback_query(DeleteStates.choosing_delete, F.data.startswith("del_match:"))
async def judge_confirm_delete(cb: types.CallbackQuery, state: FSMContext):
    mid = int(cb.data.split(":",1)[1])
    conn, cur = conn_cursor()
    cur.execute("SELECT team1_id, team2_id, date, time FROM matches WHERE id=?", (mid,))
    row = cur.fetchone()
    if not row:
        conn.close()
        await cb.message.answer("–ú–∞—Ç—á –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await cb.answer()
        await state.clear()
        return
    t1, t2, d, tm = row
    cur.execute("DELETE FROM matches WHERE id=?", (mid,))
    conn.commit()
    conn.close()
    await cb.message.answer(f"–ú–∞—Ç—á ID {mid} —É–¥–∞–ª—ë–Ω ‚úÖ")
    await send_safe(t1, f"‚ùå –ú–∞—Ç—á ID {mid} ({d} {tm}) –±—ã–ª —É–¥–∞–ª—ë–Ω —Å—É–¥—å—ë–π.")
    if t2:
        await send_safe(t2, f"‚ùå –ú–∞—Ç—á ID {mid} ({d} {tm}) –±—ã–ª —É–¥–∞–ª—ë–Ω —Å—É–¥—å—ë–π.")
    if GROUP_CHAT_ID:
        try:
            await bot.send_message(GROUP_CHAT_ID, f"‚ùå –ú–∞—Ç—á ID {mid} ({d} {tm}) –±—ã–ª —É–¥–∞–ª—ë–Ω —Å—É–¥—å—ë–π.")
        except Exception:
            pass
    await cb.answer()
    await state.clear()

# ----------------- Back button handler -----------------
@dp.message(F.text == "üîô –ù–∞–∑–∞–¥")
async def back_to_menu(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if is_commander(user_id):
        await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é –∫–æ–º–∞–Ω–¥–∏—Ä–∞:", reply_markup=commander_menu)
    elif is_judge(user_id):
        await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é —Å—É–¥—å–∏:", reply_markup=judge_menu)
    else:
        await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=role_kb)
    await state.clear()

# ----------------- Misc admin commands -----------------
@dp.message(Command("list_teams"))
async def admin_list_teams(message: types.Message):
    if message.from_user.id not in ADMINS:
        return
    conn, cur = conn_cursor()
    cur.execute("SELECT user_id, team_name, phone, approved FROM users WHERE role='commander'")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ö–æ–º–∞–Ω–¥ –Ω–µ—Ç.")
        return
    lines = [f"UserID: {uid} | Team: {tn} | Phone: {ph} | Approved: {ap}" for uid, tn, ph, ap in rows]
    await message.answer("–°–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥:\n" + "\n".join(lines))

@dp.message(Command("list_judges"))
async def admin_list_judges(message: types.Message):
    if message.from_user.id not in ADMINS:
        return
    conn, cur = conn_cursor()
    cur.execute("SELECT user_id, phone, approved FROM users WHERE role='judge'")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–°—É–¥–µ–π –Ω–µ—Ç.")
        return
    lines = [f"UserID: {uid} | Phone: {ph} | Approved: {ap}" for uid, ph, ap in rows]
    await message.answer("–°–ø–∏—Å–æ–∫ —Å—É–¥–µ–π:\n" + "\n".join(lines))

@dp.message(Command("del_team"))
async def admin_del_team(message: types.Message):
    if message.from_user.id not in ADMINS:
        return
    parts = message.text.split()
    if len(parts) < 2:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /del_team <user_id>")
        return
    try:
        uid = int(parts[1])
    except ValueError:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π user_id")
        return
    conn, cur = conn_cursor()
    cur.execute("DELETE FROM users WHERE user_id=? AND role='commander'", (uid,))
    conn.commit()
    conn.close()
    await message.answer(f"–ö–æ–º–∞–Ω–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} —É–¥–∞–ª–µ–Ω–∞.")

@dp.message(Command("del_judge"))
async def admin_del_judge(message: types.Message):
    if message.from_user.id not in ADMINS:
        return
    parts = message.text.split()
    if len(parts) < 2:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /del_judge <user_id>")
        return
    try:
        uid = int(parts[1])
    except ValueError:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π user_id")
        return
    conn, cur = conn_cursor()
    cur.execute("DELETE FROM users WHERE user_id=? AND role='judge'", (uid,))
    conn.commit()
    conn.close()
    await message.answer(f"–°—É–¥—å—è {uid} —É–¥–∞–ª—ë–Ω.")

# ----------------- Start polling -----------------
async def main():
    logger.info("–£–¥–∞–ª—è–µ–º webhook (–µ—Å–ª–∏ –µ—Å—Ç—å) –∏ –∑–∞–ø—É—Å–∫–∞–µ–º polling")
    try:
        await bot.delete_webhook(drop_pending_updates=True)
    except Exception as e:
        logger.info("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ webhook: %s", e)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
