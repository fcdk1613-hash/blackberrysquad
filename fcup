#!/usr/bin/env python3
# fcup - final bot (aiogram 3.x)
import asyncio
import logging
import sqlite3
from datetime import datetime, date, time, timedelta

from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import CommandStart
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove,
    InlineKeyboardMarkup, InlineKeyboardButton
)

# -----------------------
# CONFIG
# -----------------------
API_TOKEN = "8392821328:AAHHINFxwpSZKGRcv0vQXogGc-pnXcAZspI"

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# -----------------------
# DB (thread safe for sqlite in this simple usage)
# -----------------------
conn = sqlite3.connect("tournament.db", check_same_thread=False)
cursor = conn.cursor()

cursor.execute("""
CREATE TABLE IF NOT EXISTS roles (
    user_id INTEGER PRIMARY KEY,
    role TEXT  -- 'commander' or 'judge'
)
""")
cursor.execute("""
CREATE TABLE IF NOT EXISTS commanders (
    user_id INTEGER PRIMARY KEY,
    phone TEXT,
    team_name TEXT
)
""")
cursor.execute("""
CREATE TABLE IF NOT EXISTS judges (
    user_id INTEGER PRIMARY KEY,
    phone TEXT,
    name TEXT
)
""")
cursor.execute("""
CREATE TABLE IF NOT EXISTS temp_schedule (
    user_id INTEGER PRIMARY KEY,
    slot TEXT   -- "YYYY-MM-DD HH:MM"
)
""")
cursor.execute("""
CREATE TABLE IF NOT EXISTS matches (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team1 TEXT,
    team2 TEXT,
    slot TEXT,        -- "YYYY-MM-DD HH:MM"
    result TEXT,      -- null or text
    judge_id INTEGER
)
""")
conn.commit()

# -----------------------
# Bot init
# -----------------------
bot = Bot(token=API_TOKEN, parse_mode="HTML")
dp = Dispatcher()

# -----------------------
# Keyboards
# -----------------------
role_kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä")],
        [KeyboardButton(text="‚öñ –Ø - —Å—É–¥—å—è")]
    ],
    resize_keyboard=True
)

contact_kb = ReplyKeyboardMarkup(
    keyboard=[[KeyboardButton(text="üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º", request_contact=True)]],
    resize_keyboard=True,
    one_time_keyboard=True
)

commander_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìÖ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—á")],
        [KeyboardButton(text="üìñ –ú–æ–∏ –º–∞—Ç—á–∏")]
    ],
    resize_keyboard=True
)

judge_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìù –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞")],
        [KeyboardButton(text="üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É")]
    ],
    resize_keyboard=True
)

# -----------------------
# In-memory per-user state for multi-step flows
# -----------------------
user_state = {}  # user_id -> dict

# -----------------------
# Helpers
# -----------------------
def dates_remaining_week():
    today = date.today()
    # include today .. upcoming Sunday
    last = today + timedelta(days=(6 - today.weekday()))
    days = []
    cur = today
    while cur <= last:
        days.append(cur.isoformat())  # YYYY-MM-DD
        cur += timedelta(days=1)
    return days

def generate_time_slots_for_date(date_iso):
    # return list of "YYYY-MM-DD HH:MM" strings from 19:00 to 22:00 step 30min
    d = datetime.fromisoformat(date_iso)
    slots = []
    hh, mm = 19, 0
    while True:
        slot_dt = datetime(d.year, d.month, d.day, hh, mm)
        slots.append(slot_dt.strftime("%Y-%m-%d %H:%M"))
        mm += 30
        if mm == 60:
            hh += 1
            mm = 0
        if hh > 22 or (hh == 22 and mm > 0):
            break
    return slots

# -----------------------
# Handlers
# -----------------------
@dp.message(CommandStart())
async def cmd_start(message: types.Message):
    await message.answer("–ü—Ä–∏–≤–µ—Ç! –í—ã–±–µ—Ä–∏ —Ä–æ–ª—å:", reply_markup=role_kb)

# Role selection -> ask for contact
@dp.message(F.text == "üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä")
async def choose_commander(message: types.Message):
    user_id = message.from_user.id
    cursor.execute("INSERT OR REPLACE INTO roles (user_id, role) VALUES (?, ?)", (user_id, "commander"))
    conn.commit()
    await message.answer("–û—Ç–ø—Ä–∞–≤—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:", reply_markup=contact_kb)

@dp.message(F.text == "‚öñ –Ø - —Å—É–¥—å—è")
async def choose_judge(message: types.Message):
    user_id = message.from_user.id
    cursor.execute("INSERT OR REPLACE INTO roles (user_id, role) VALUES (?, ?)", (user_id, "judge"))
    conn.commit()
    await message.answer("–û—Ç–ø—Ä–∞–≤—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:", reply_markup=contact_kb)

# Contact handler (phone sent)
@dp.message(F.content_type == types.ContentType.CONTACT)
async def contact_received(message: types.Message):
    contact = message.contact
    user_id = message.from_user.id
    phone = contact.phone_number

    role_row = cursor.execute("SELECT role FROM roles WHERE user_id = ?", (user_id,)).fetchone()
    if not role_row:
        # user pressed contact without picking role
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ —Ä–æ–ª—å (–∫–æ–º–∞–Ω–¥–∏—Ä / —Å—É–¥—å—è).", reply_markup=role_kb)
        return

    role = role_row[0]
    if role == "commander":
        # save phone and set expect team name
        cursor.execute("INSERT OR REPLACE INTO commanders (user_id, phone, team_name) VALUES (?, ?, NULL)", (user_id, phone))
        conn.commit()
        user_state[user_id] = {"expect_team_name": True}
        await message.answer("–°–ø–∞—Å–∏–±–æ! –¢–µ–ø–µ—Ä—å –ø—Ä–∏—à–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã (–æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ).", reply_markup=ReplyKeyboardRemove())
        return

    if role == "judge":
        cursor.execute("INSERT OR REPLACE INTO judges (user_id, phone, name) VALUES (?, ?, ?)",
                       (user_id, phone, message.from_user.full_name))
        conn.commit()
        # judge menu
        await message.answer("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è ‚úÖ", reply_markup=judge_menu)
        return

# Team name input (only when expected)
@dp.message(F.text & ~F.contact)
async def text_input(message: types.Message):
    user_id = message.from_user.id
    txt = message.text.strip()

    # if expecting team name
    st = user_state.get(user_id)
    if st and st.get("expect_team_name"):
        if not txt:
            await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
            return
        cursor.execute("UPDATE commanders SET team_name = ? WHERE user_id = ?", (txt, user_id))
        conn.commit()
        user_state.pop(user_id, None)
        await message.answer(f"–ö–æ–º–∞–Ω–¥–∞ <b>{txt}</b> –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞ ‚úÖ", reply_markup=commander_menu)
        return

    # If in judge-enter-result flow: handle below (but we use explicit state 'enter_result')
    if st and st.get("action") == "enter_result":
        match_id = st.get("match_id")
        result_text = txt
        cursor.execute("UPDATE matches SET result = ?, judge_id = ? WHERE id = ?", (result_text, user_id, match_id))
        conn.commit()
        user_state.pop(user_id, None)
        await message.answer("–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω ‚úÖ", reply_markup=judge_menu)
        return

    # nothing to do here for other texts
    # fallback: ignore (prevents interfering with button handlers)
    return

# -----------------------
# Commander: schedule match (inline date -> inline time)
# -----------------------
@dp.message(F.text == "üìÖ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—á")
async def schedule_start(message: types.Message):
    user_id = message.from_user.id
    # check registered commander with team_name
    row = cursor.execute("SELECT team_name FROM commanders WHERE user_id = ?", (user_id,)).fetchone()
    if not row or not row[0]:
        await message.answer("–¢—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä –∏–ª–∏ –Ω–µ —É–∫–∞–∑–∞–ª –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã. –°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Å—è.")
        return

    dates = dates_remaining_week()
    buttons = [[InlineKeyboardButton(text=d, callback_data=f"schedule_date|{d}")] for d in dates]
    kb = InlineKeyboardMarkup(inline_keyboard=buttons)
    user_state[user_id] = {"action": "scheduling"}
    await message.answer("–í—ã–±–µ—Ä–∏ –¥–∞—Ç—É (–æ—Å—Ç–∞—Ç–æ–∫ –Ω–µ–¥–µ–ª–∏):", reply_markup=kb)

@dp.callback_query(F.data.startswith("schedule_date|"))
async def schedule_choose_date(cb: types.CallbackQuery):
    user_id = cb.from_user.id
    data = cb.data.split("|", 1)[1]  # YYYY-MM-DD
    # ensure user in scheduling state
    st = user_state.get(user_id)
    if not st or st.get("action") != "scheduling":
        await cb.answer("–°–Ω–∞—á–∞–ª–∞ –Ω–∞–∂–º–∏ '–ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—á'.")
        return

    # build times
    slots = generate_time_slots_for_date(data)
    buttons = [[InlineKeyboardButton(text=s.split()[1], callback_data=f"schedule_time|{s}")] for s in slots]
    kb = InlineKeyboardMarkup(inline_keyboard=buttons)
    st["date"] = data
    await cb.message.answer(f"–í—ã–±–µ—Ä–∏ –≤—Ä–µ–º—è –¥–ª—è {data}:", reply_markup=kb)
    await cb.answer()

@dp.callback_query(F.data.startswith("schedule_time|"))
async def schedule_choose_time(cb: types.CallbackQuery):
    user_id = cb.from_user.id
    slot = cb.data.split("|", 1)[1]  # "YYYY-MM-DD HH:MM"
    st = user_state.get(user_id)
    if not st or st.get("action") != "scheduling":
        await cb.answer("–°–Ω–∞—á–∞–ª–∞ –Ω–∞–∂–º–∏ '–ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—á'.")
        return

    # confirm team exists
    row = cursor.execute("SELECT team_name FROM commanders WHERE user_id = ?", (user_id,)).fetchone()
    if not row or not row[0]:
        await cb.message.answer("–û—à–∏–±–∫–∞: —É —Ç–µ–±—è –Ω–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        user_state.pop(user_id, None)
        await cb.answer()
        return
    team_name = row[0]

    # check for opponent waiting in temp_schedule on same slot
    opp = cursor.execute("SELECT user_id FROM temp_schedule WHERE slot = ? AND user_id != ?", (slot, user_id)).fetchone()
    if opp:
        opponent_id = opp[0]
        # get opponent team name
        opp_team_row = cursor.execute("SELECT team_name FROM commanders WHERE user_id = ?", (opponent_id,)).fetchone()
        if not opp_team_row or not opp_team_row[0]:
            # remove opponent from temp and add current to temp
            cursor.execute("DELETE FROM temp_schedule WHERE user_id = ?", (opponent_id,))
            conn.commit()
            cursor.execute("INSERT OR REPLACE INTO temp_schedule (user_id, slot) VALUES (?, ?)", (user_id, slot))
            conn.commit()
            await cb.message.answer("–°–æ–ø–µ—Ä–Ω–∏–∫ –µ—Å—Ç—å, –Ω–æ —É –Ω–µ–≥–æ –Ω–µ—Ç –∏–º–µ–Ω–∏ –∫–æ–º–∞–Ω–¥—ã. –¢—ã –¥–æ–±–∞–≤–ª–µ–Ω –≤ –æ–∂–∏–¥–∞–Ω–∏–µ.", reply_markup=commander_menu)
            user_state.pop(user_id, None)
            await cb.answer()
            return
        opponent_team = opp_team_row[0]

        # create match
        cursor.execute("INSERT INTO matches (team1, team2, slot, result) VALUES (?, ?, ?, NULL)",
                       (team_name, opponent_team, slot))
        conn.commit()
        # delete any temp_schedule entries for this slot (both)
        cursor.execute("DELETE FROM temp_schedule WHERE slot = ?", (slot,))
        conn.commit()

        # notify both
        await bot.send_message(user_id, f"‚úÖ –ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω: {team_name} vs {opponent_team} ‚Äî {slot}", reply_markup=commander_menu)
        await bot.send_message(opponent_id, f"‚úÖ –ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω: {opponent_team} vs {team_name} ‚Äî {slot}", reply_markup=commander_menu)
        user_state.pop(user_id, None)
        await cb.answer("–ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω")
        return

    # else: add to temp_schedule and wait
    cursor.execute("INSERT OR REPLACE INTO temp_schedule (user_id, slot) VALUES (?, ?)", (user_id, slot))
    conn.commit()
    await cb.message.answer(f"–¢—ã –¥–æ–±–∞–≤–ª–µ–Ω(–∞) –≤ –æ–∂–∏–¥–∞–Ω–∏–µ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –Ω–∞ {slot}. –ö–∞–∫ —Ç–æ–ª—å–∫–æ –Ω–∞–π–¥—ë—Ç—Å—è ‚Äî –æ–±–æ–∏–º –ø—Ä–∏–¥—ë—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ.", reply_markup=commander_menu)
    user_state.pop(user_id, None)
    await cb.answer()

# Commander: my matches
@dp.message(F.text == "üìñ –ú–æ–∏ –º–∞—Ç—á–∏")
async def commander_my_matches(message: types.Message):
    user_id = message.from_user.id
    row = cursor.execute("SELECT team_name FROM commanders WHERE user_id = ?", (user_id,)).fetchone()
    if not row or not row[0]:
        await message.answer("–¢—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä.", reply_markup=role_kb)
        return
    team = row[0]
    rows = cursor.execute("SELECT team1, team2, slot, result FROM matches WHERE team1 = ? OR team2 = ? ORDER BY slot", (team, team)).fetchall()
    if not rows:
        await message.answer("–£ —Ç–≤–æ–µ–π –∫–æ–º–∞–Ω–¥—ã –ø–æ–∫–∞ –Ω–µ—Ç –º–∞—Ç—á–µ–π.", reply_markup=commander_menu)
        return
    text = f"–ú–∞—Ç—á–∏ –∫–æ–º–∞–Ω–¥—ã {team}:\n\n"
    for r in rows:
        opp = r[1] if r[0] == team else r[0]
        text += f"{r[2]} ‚Äî vs {opp} ‚Äî {r[3] if r[3] else '—Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ —É–∫–∞–∑–∞–Ω'}\n"
    await message.answer(text, reply_markup=commander_menu)

# -----------------------
# Judge: add result flow
# -----------------------
@dp.message(F.text == "üìù –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞")
async def judge_list_matches(message: types.Message):
    rows = cursor.execute("SELECT id, team1, team2, slot FROM matches WHERE result IS NULL").fetchall()
    if not rows:
        await message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.", reply_markup=judge_menu)
        return
    buttons = [[InlineKeyboardButton(text=f"{r[1]} vs {r[2]} ({r[3]})", callback_data=f"match_id|{r[0]}")] for r in rows]
    kb = InlineKeyboardMarkup(inline_keyboard=buttons)
    await message.answer("–í—ã–±–µ—Ä–∏ –º–∞—Ç—á –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞:", reply_markup=kb)

@dp.callback_query(F.data.startswith("match_id|"))
async def judge_choose_match(cb: types.CallbackQuery):
    match_id = int(cb.data.split("|", 1)[1])
    user_state[cb.from_user.id] = {"action": "enter_result", "match_id": match_id}
    await cb.message.answer("–í–≤–µ–¥–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä: TeamA 2:1 TeamB):", reply_markup=ReplyKeyboardRemove())
    await cb.answer()

# results input handled in text_input() above when user_state action == 'enter_result'

# -----------------------
# Judge: results by date
# -----------------------
@dp.message(F.text == "üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É" or F.text == "üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É")
async def judge_choose_result_date(message: types.Message):
    rows = cursor.execute("SELECT DISTINCT date(slot) FROM matches WHERE result IS NOT NULL").fetchall()
    if not rows:
        await message.answer("–ü–æ–∫–∞ –Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.", reply_markup=judge_menu)
        return
    buttons = [[InlineKeyboardButton(text=r[0], callback_data=f"resdate|{r[0]}")] for r in rows]
    kb = InlineKeyboardMarkup(inline_keyboard=buttons)
    await message.answer("–í—ã–±–µ—Ä–∏ –¥–∞—Ç—É:", reply_markup=kb)

@dp.callback_query(F.data.startswith("resdate|"))
async def show_results_by_date(cb: types.CallbackQuery):
    date_str = cb.data.split("|", 1)[1]
    rows = cursor.execute("SELECT team1, team2, slot, result FROM matches WHERE date(slot) = ? AND result IS NOT NULL", (date_str,)).fetchall()
    if not rows:
        await cb.message.answer("–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∑–∞ —ç—Ç—É –¥–∞—Ç—É.")
        await cb.answer()
        return
    text = f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ {date_str}:\n\n"
    for r in rows:
        text += f"{r[2]} ‚Äî {r[0]} vs {r[1]} ‚Äî {r[3]}\n"
    await cb.message.answer(text, reply_markup=judge_menu)
    await cb.answer()

# -----------------------
# Fallback debug - do not intercept handled buttons above
# -----------------------
@dp.message(F.text)
async def fallback(message: types.Message):
    # ignore known menu texts so they are handled earlier; otherwise log unknown messages
    known = {
        "üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä", "‚öñ –Ø - —Å—É–¥—å—è",
        "üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º",
        "üìÖ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—á", "üìñ –ú–æ–∏ –º–∞—Ç—á–∏",
        "üìù –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞", "üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É",
    }
    if message.text not in known:
        logger.info("Unhandled text from %s: %s", message.from_user.id, message.text)
    # No reply here so we don't block other flows

# -----------------------
# Start polling
# -----------------------
async def main():
    logger.info("Starting bot, deleting webhook if any")
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
