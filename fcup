#!/usr/bin/env python3
# fcup - squad tournament bot (aiogram 3.x) ‚Äî final corrected

import asyncio
import logging
import sqlite3
from datetime import datetime, date, timedelta

from aiogram import Bot, Dispatcher, F, types
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import Command
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton,
    InlineKeyboardMarkup, InlineKeyboardButton
)
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State

# ---------------- CONFIG ----------------
API_TOKEN = "8392821328:AAHHINFxwpSZKGRcv0vQXogGc-pnXcAZspI"

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --------------- DB ---------------------
# –ò—Å–ø–æ–ª—å–∑—É–µ–º check_same_thread=False –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã (–Ω–µ –¥–ª—è –≤—ã—Å–æ–∫–æ–Ω–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –ø—Ä–æ–¥–∞–∫—à–µ–Ω–æ–≤)
conn = sqlite3.connect("tournament.db", check_same_thread=False)
cursor = conn.cursor()

# users: user_id, phone, role ('commander' or 'judge'), team_name (–¥–ª—è –∫–æ–º–∞–Ω–¥–∏—Ä–æ–≤)
cursor.execute("""
CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    phone TEXT,
    role TEXT,
    team_name TEXT
)
""")

# match_requests: –∑–∞—è–≤–∫–∏ –∫–æ–º–∞–Ω–¥ –Ω–∞ —Å–ª–æ—Ç (–ø–æ–∫–∞ –Ω–µ—Ç —Å–æ–ø–µ—Ä–Ω–∏–∫–∞)
cursor.execute("""
CREATE TABLE IF NOT EXISTS match_requests (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team_id INTEGER,
    date TEXT,   -- YYYY-MM-DD
    time TEXT    -- HH:MM (19:00/20:00/21:00)
)
""")

# matches: —Å–æ–∑–¥–∞–Ω–Ω—ã–µ –º–∞—Ç—á–∏ (—Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –æ–±–µ –∫–æ–º–∞–Ω–¥—ã —Å–æ–≤–ø–∞–ª–∏)
cursor.execute("""
CREATE TABLE IF NOT EXISTS matches (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team1_id INTEGER,
    team2_id INTEGER,
    date TEXT,
    time TEXT,
    result TEXT,
    judge_id INTEGER
)
""")

conn.commit()

# ------------- FSM states ---------------
class RegStates(StatesGroup):
    choosing_role = State()
    waiting_for_phone = State()
    waiting_for_team_name = State()

class ScheduleStates(StatesGroup):
    choosing_date = State()
    choosing_time = State()

class JudgeStates(StatesGroup):
    entering_result = State()

# ------------- Bot init -----------------
bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher(storage=MemoryStorage())

# ------------- Keyboards ----------------
role_kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä"), KeyboardButton(text="‚öñÔ∏è –Ø - —Å—É–¥—å—è")]
    ],
    resize_keyboard=True
)

contact_kb = ReplyKeyboardMarkup(
    keyboard=[[KeyboardButton(text="üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º", request_contact=True)]],
    resize_keyboard=True,
    one_time_keyboard=True
)

commander_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É")],
        [KeyboardButton(text="üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")],
        [KeyboardButton(text="üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É")] 
    ],
    resize_keyboard=True
)

judge_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìù –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç")],
        [KeyboardButton(text="üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É")]
    ],
    resize_keyboard=True
)

# ------------- Helpers ------------------
def dates_next_week():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –¥–∞—Ç (YYYY-MM-DD) –¥–ª—è –±–ª–∏–∂–∞–π—à–∏—Ö 7 –¥–Ω–µ–π –≤–∫–ª—é—á–∞—è —Å–µ–≥–æ–¥–Ω—è."""
    today = date.today()
    return [(today + timedelta(days=i)).isoformat() for i in range(7)]

def send_safe(user_id: int, text: str):
    """–ü–æ–ø—ã—Ç–∫–∞ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ‚Äî –æ–±—ë—Ä—Ç–∫–∞."""
    async def _send():
        try:
            await bot.send_message(user_id, text)
        except Exception as e:
            logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ %s: %s", user_id, e)
    asyncio.create_task(_send())

# ------------- Handlers -----------------

@dp.message(Command("start"))
async def cmd_start(message: types.Message, state: FSMContext):
    # –ï—Å–ª–∏ —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é –ø–æ —Ä–æ–ª–∏
    cursor.execute("SELECT role, team_name FROM users WHERE user_id = ?", (message.from_user.id,))
    r = cursor.fetchone()
    if r:
        role = r[0]
        if role == "commander":
            await message.answer("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä.", reply_markup=commander_menu)
        else:
            await message.answer("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è.", reply_markup=judge_menu)
        return

    await message.answer("–ü—Ä–∏–≤–µ—Ç! –í—ã–±–µ—Ä–∏ —Ä–æ–ª—å:", reply_markup=role_kb)
    await state.set_state(RegStates.choosing_role)


# --- –í—ã–±–æ—Ä —Ä–æ–ª–∏ ---
@dp.message(RegStates.choosing_role, F.text.in_(["üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä", "‚öñÔ∏è –Ø - —Å—É–¥—å—è"]))
async def choose_role(message: types.Message, state: FSMContext):
    role = "commander" if message.text == "üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä" else "judge"
    await state.update_data(chosen_role=role)
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞:", reply_markup=contact_kb)
    await state.set_state(RegStates.waiting_for_phone)


# --- –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–∞–∫—Ç–∞ ---
@dp.message(RegStates.waiting_for_phone, F.content_type == types.ContentType.CONTACT)
async def got_contact(message: types.Message, state: FSMContext):
    phone = message.contact.phone_number
    data = await state.get_data()
    role = data.get("chosen_role")
    user_id = message.from_user.id

    cursor.execute("INSERT OR REPLACE INTO users (user_id, phone, role) VALUES (?, ?, ?)",
                   (user_id, phone, role))
    conn.commit()

    if role == "commander":
        await message.answer("–û—Ç–ª–∏—á–Ω–æ. –í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã (–æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ):", reply_markup=types.ReplyKeyboardRemove())
        await state.set_state(RegStates.waiting_for_team_name)
    else:
        await message.answer("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è ‚úÖ", reply_markup=judge_menu)
        await state.clear()


# --- –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã ---
@dp.message(RegStates.waiting_for_team_name, F.text)
async def got_team_name(message: types.Message, state: FSMContext):
    team_name = message.text.strip()
    if not team_name:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ –µ—â—ë —Ä–∞–∑.")
        return

    user_id = message.from_user.id
    cursor.execute("UPDATE users SET team_name = ? WHERE user_id = ?", (team_name, user_id))
    conn.commit()

    await message.answer(f"–ö–æ–º–∞–Ω–¥–∞ <b>{team_name}</b> –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞ ‚úÖ", reply_markup=commander_menu)
    await state.clear()


# --- –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É (–∫–æ–º–∞–Ω–¥–∏—Ä) ---
@dp.message(F.text == "üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É")
async def start_schedule(message: types.Message, state: FSMContext):
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∏ –Ω–∞–ª–∏—á–∏—è team_name
    cursor.execute("SELECT role, team_name FROM users WHERE user_id = ?", (message.from_user.id,))
    row = cursor.fetchone()
    if not row or row[0] != "commander" or not row[1]:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä –∏ —É–∫–∞–∂–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã.")
        return

    dates = dates_next_week()
    inline_buttons = []
    # –°—Ç—Ä–æ–∏–º —Å—Ç—Ä–æ–∫–∏ –ø–æ 1-2 –¥–∞—Ç—ã –Ω–∞ —Å—Ç—Ä–æ–∫—É –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
    for d in dates:
        inline_buttons.append([InlineKeyboardButton(text=d, callback_data=f"slot_date:{d}")])

    kb = InlineKeyboardMarkup(inline_keyboard=inline_buttons)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π):", reply_markup=kb)
    await state.set_state(ScheduleStates.choosing_date)


@dp.callback_query(F.data.startswith("slot_date:"))
async def on_date_chosen(cb: types.CallbackQuery, state: FSMContext):
    _, date_iso = cb.data.split(":", 1)
    # –ü—Ä–µ–¥–ª–∞–≥–∞–µ–º —Ç—Ä–∏ –≤—Ä–µ–º–µ–Ω–∏
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="19:00", callback_data=f"slot_time:{date_iso}|19:00")],
        [InlineKeyboardButton(text="20:00", callback_data=f"slot_time:{date_iso}|20:00")],
        [InlineKeyboardButton(text="21:00", callback_data=f"slot_time:{date_iso}|21:00")]
    ])
    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω–∞ –¥–∞—Ç–∞ {date_iso}. –í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è:", reply_markup=kb)
    await cb.answer()
    # –æ—Å—Ç–∞–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ ScheduleStates.choosing_date (–∏–ª–∏ –º–æ–∂–Ω–æ –ø–æ–º–µ—Ç–∏—Ç—å –¥–∞—Ç—É –≤ FSM)
    await state.update_data(chosen_date=date_iso)


@dp.callback_query(F.data.startswith("slot_time:"))
async def on_time_chosen(cb: types.CallbackQuery, state: FSMContext):
    # callback data: slot_time:YYYY-MM-DD|HH:MM
    _, rest = cb.data.split(":", 1)
    date_iso, time_str = rest.split("|", 1)
    user_id = cb.from_user.id

    # –ü—Ä–æ–≤–µ—Ä–∫–∏: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∫–æ–º–∞–Ω–¥–∏—Ä–æ–º —Å team_name
    cursor.execute("SELECT role, team_name FROM users WHERE user_id = ?", (user_id,))
    row = cursor.fetchone()
    if not row or row[0] != "commander" or not row[1]:
        await cb.message.answer("–í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º –∫–æ–º–∞–Ω–¥—ã.")
        await cb.answer()
        return
    team_name = row[1]

    # –ü–æ–∏—Å–∫ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –≤ match_requests
    cursor.execute("SELECT id, team_id FROM match_requests WHERE date = ? AND time = ? AND team_id != ?", (date_iso, time_str, user_id))
    opp = cursor.fetchone()
    if opp:
        opp_request_id, opp_team_id = opp
        # –°–æ–∑–¥–∞—ë–º –º–∞—Ç—á —Å –¥–≤—É–º—è –∫–æ–º–∞–Ω–¥–∞–º–∏
        cursor.execute("INSERT INTO matches (team1_id, team2_id, date, time, result) VALUES (?, ?, ?, ?, NULL)",
                       (opp_team_id, user_id, date_iso, time_str))
        conn.commit()
        # –£–¥–∞–ª—è–µ–º –≤—Å–µ –∑–∞—è–≤–∫–∏ –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç
        cursor.execute("DELETE FROM match_requests WHERE date = ? AND time = ? AND team1_id NOT IN", (date_iso, time_str))
        conn.commit()

        # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥
        cursor.execute("SELECT team_name FROM users WHERE user_id = ?", (opp_team_id,))
        opp_team_name_row = cursor.fetchone()
        opp_team_name = opp_team_name_row[0] if opp_team_name_row and opp_team_name_row[0] else str(opp_team_id)

        # –£–≤–µ–¥–æ–º–ª—è–µ–º –æ–±–æ–∏—Ö
        await cb.message.answer(f"‚úÖ –ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω: <b>{team_name}</b> vs <b>{opp_team_name}</b> ‚Äî {date_iso} {time_str}", reply_markup=commander_menu)
        send_safe(opp_team_id, f"‚úÖ –ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω: <b>{opp_team_name}</b> vs <b>{team_name}</b> ‚Äî {date_iso} {time_str}")
        await cb.answer("–ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω ‚úÖ")
    else:
        # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞—è–≤–∫—É
        cursor.execute("INSERT INTO match_requests (team_id, date, time) VALUES (?, ?, ?)", (user_id, date_iso, time_str))
        conn.commit()
        await cb.message.answer(f"–ó–∞—è–≤–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {team_name} ‚Äî {date_iso} {time_str}. –û–∂–∏–¥–∞–µ–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞...", reply_markup=commander_menu)
        await cb.answer("–ó–∞—è–≤–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ ‚è≥")


# --- –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ (–∫–æ–º–∞–Ω–¥–∏—Ä) ---
@dp.message(F.text == "üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
async def my_schedule(message: types.Message):
    user_id = message.from_user.id
    cursor.execute("SELECT team_name FROM users WHERE user_id = ?", (user_id,))
    t = cursor.fetchone()
    if not t or not t[0]:
        await message.answer("–í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º –∫–æ–º–∞–Ω–¥—ã.")
        return
    team_name = t[0]

    # –ù–∞—Ö–æ–¥–∏–º –º–∞—Ç—á–∏, –≥–¥–µ —É—á–∞—Å—Ç–≤—É–µ—Ç —ç—Ç–æ—Ç —é–∑–µ—Ä –∫–∞–∫ team1 –∏–ª–∏ team2
    cursor.execute("""
        SELECT m.date, m.time, m.result, m.team1_id, m.team2_id
        FROM matches m
        WHERE m.team1_id = ? OR m.team2_id = ?
        ORDER BY m.date, m.time
    """, (user_id, user_id))
    rows = cursor.fetchall()
    if not rows:
        await message.answer("–£ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã –ø–æ–∫–∞ –Ω–µ—Ç –º–∞—Ç—á–µ–π.", reply_markup=commander_menu)
        return

    text = f"üìñ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã <b>{team_name}</b>:\n\n"
    for r in rows:
        date_iso, time_str, result, t1, t2 = r
        # –ü–æ–ª—É—á–∞–µ–º –∏–º–µ–Ω–∞ –∫–æ–º–∞–Ω–¥
        cursor.execute("SELECT team_name FROM users WHERE user_id = ?", (t1,))
        n1 = cursor.fetchone()
        n1 = n1[0] if n1 and n1[0] else str(t1)
        cursor.execute("SELECT team_name FROM users WHERE user_id = ?", (t2,))
        n2 = cursor.fetchone()
        n2 = n2[0] if n2 and n2[0] else str(t2) if t2 else "–û–∂–∏–¥–∞–µ—Ç—Å—è —Å–æ–ø–µ—Ä–Ω–∏–∫"
        text += f"{date_iso} {time_str} ‚Äî {n1} vs {n2} ‚Äî {result if result else '—Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –Ω–µ—Ç'}\n"
    await message.answer(text, reply_markup=commander_menu)


# ------------- –°—É–¥—å—è: –¥–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç -------------
@dp.message(F.text == "üìù –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç")
async def judge_list_matches(message: types.Message, state: FSMContext):
    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –º–∞—Ç—á–∏, –≥–¥–µ –µ—Å—Ç—å –æ–±–∞ —É—á–∞—Å—Ç–Ω–∏–∫–∞ (team2_id IS NOT NULL) –∏ result IS NULL
    cursor.execute("SELECT id, team1_id, team2_id, date, time FROM matches WHERE team1_id IS NOT NULL AND team2_id IS NOT NULL AND result IS NULL")
    rows = cursor.fetchall()
    if not rows:
        await message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –¥–ª—è –≤–Ω–µ—Å–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.", reply_markup=judge_menu)
        return

    inline = []
    for r in rows:
        mid, t1, t2, d, tm = r
        cursor.execute("SELECT team_name FROM users WHERE user_id = ?", (t1,))
        n1 = cursor.fetchone(); n1 = n1[0] if n1 and n1[0] else str(t1)
        cursor.execute("SELECT team_name FROM users WHERE user_id = ?", (t2,))
        n2 = cursor.fetchone(); n2 = n2[0] if n2 and n2[0] else str(t2)
        inline.append([InlineKeyboardButton(text=f"{n1} vs {n2} ‚Äî {d} {tm}", callback_data=f"judge_match:{mid}")])

    kb = InlineKeyboardMarkup(inline_keyboard=inline)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á –¥–ª—è –≤–Ω–µ—Å–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞:", reply_markup=kb)
    await state.clear()


@dp.callback_query(F.data.startswith("judge_match:"))
async def judge_pick_match(cb: types.CallbackQuery, state: FSMContext):
    _, mid = cb.data.split(":", 1)
    mid = int(mid)
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ state match id
    await state.update_data(judge_match_id=mid)
    await state.set_state(JudgeStates.entering_result)
    await cb.message.answer("–í–≤–µ–¥–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: 2:1):", reply_markup=types.ReplyKeyboardRemove())
    await cb.answer()


@dp.message(JudgeStates.entering_result, F.text)
async def judge_save_result(message: types.Message, state: FSMContext):
    data = await state.get_data()
    mid = data.get("judge_match_id")
    if not mid:
        await message.answer("–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω –º–∞—Ç—á –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏.")
        await state.clear()
        return

    result_text = message.text.strip()
    cursor.execute("UPDATE matches SET result = ?, judge_id = ? WHERE id = ?", (result_text, message.from_user.id, mid))
    conn.commit()

    # notify both teams
    cursor.execute("SELECT team1_id, team2_id, date, time FROM matches WHERE id = ?", (mid,))
    row = cursor.fetchone()
    if row:
        t1, t2, d, tm = row
        send_safe(t1, f"–†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ {d} {tm} ‚Äî {result_text}")
        if t2:
            send_safe(t2, f"–†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ {d} {tm} ‚Äî {result_text}")

    await message.answer("–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω ‚úÖ", reply_markup=judge_menu)
    await state.clear()


# ------------- –°—É–¥—å—è: —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É -------------
@dp.message(F.text == "üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É")
async def judge_results_by_date(message: types.Message):
    cursor.execute("SELECT DISTINCT date FROM matches WHERE result IS NOT NULL ORDER BY date")
    dates = [r[0] for r in cursor.fetchall()]
    if not dates:
        await message.answer("–ü–æ–∫–∞ –Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.")
        return

    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=d, callback_data=f"resdate:{d}") ] for d in dates])
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É:", reply_markup=kb)


@dp.callback_query(F.data.startswith("resdate:"))
async def show_results_by_date(cb: types.CallbackQuery):
    _, d = cb.data.split(":", 1)
    cursor.execute("SELECT team1_id, team2_id, time, result FROM matches WHERE date = ? AND result IS NOT NULL", (d,))
    rows = cursor.fetchall()
    if not rows:
        await cb.message.answer("–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∑–∞ —ç—Ç—É –¥–∞—Ç—É.")
        await cb.answer()
        return

    text = f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ {d}:\n\n"
    for r in rows:
        t1, t2, tm, res = r
        cursor.execute("SELECT team_name FROM users WHERE user_id = ?", (t1,))
        n1 = cursor.fetchone(); n1 = n1[0] if n1 and n1[0] else str(t1)
        cursor.execute("SELECT team_name FROM users WHERE user_id = ?", (t2,))
        n2 = cursor.fetchone(); n2 = n2[0] if n2 and n2[0] else str(t2)
        text += f"{tm} ‚Äî {n1} vs {n2} ‚Äî {res}\n"
    await cb.message.answer(text)
    await cb.answer()


# ------------- Fallback (–≤ –∫–æ–Ω—Ü–µ) -------------
@dp.message(F.text)
async def fallback_text(message: types.Message):
    # –ª–æ–≥–∏—Ä—É–µ–º –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ —Ç–µ–∫—Å—Ç—ã, –Ω–æ –Ω–µ –º–µ—à–∞–µ–º —Ä–∞–±–æ—á–∏–º flows
    known_buttons = {
        "üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä", "‚öñÔ∏è –Ø - —Å—É–¥—å—è",
        "üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É", "üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ",
        "üìù –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç", "üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É",
        "üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º"
    }
    if message.text not in known_buttons:
        logger.info("Unhandled text from %s: %s", message.from_user.id, message.text)


# ------------- –ó–∞–ø—É—Å–∫ -------------
async def main():
    logger.info("Deleting webhook (if any) and starting polling")
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
