#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
–ü–æ–ª–Ω—ã–π —Ä–∞–±–æ—á–∏–π –∫–æ–¥ –±–æ—Ç–∞ —Ç—É—Ä–Ω–∏—Ä–∞ Squad (aiogram 3.x).
–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª:
- —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É (–∫–æ–º–∞–Ω–¥–∏—Ä / —Å—É–¥—å—è)
- –∫–æ–º–∞–Ω–¥–∏—Ä—ã: —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∫–æ–º–∞–Ω–¥—ã, –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Ç—á–µ–π (–≤—ã–±–æ—Ä –¥–∞—Ç—ã –∏–∑ –±–ª–∏–∂–∞–π—à–∏—Ö 7 –¥–Ω–µ–π, –≤—Ä–µ–º—è 19:00/20:00/21:00),
  –ø—Ä–æ—Å–º–æ—Ç—Ä —Å–≤–æ–∏—Ö –∑–∞—è–≤–æ–∫, —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è, –∏—Å—Ç–æ—Ä–∏–∏ –º–∞—Ç—á–µ–π
- –∑–∞—â–∏—Ç–∞ –æ—Ç –¥—É–±–ª–µ–π (–æ–¥–Ω–æ–π –∫–æ–º–∞–Ω–¥–µ –Ω–µ–ª—å–∑—è –∏–º–µ—Ç—å –¥–≤–∞ –º–∞—Ç—á–∞ –≤ –æ–¥–Ω–æ –≤—Ä–µ–º—è)
- –ø—Ä–∏ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏ –∑–∞—è–≤–æ–∫ —Å–æ–∑–¥–∞—ë—Ç—Å—è –º–∞—Ç—á; –æ–±–µ –∫–æ–º–∞–Ω–¥—ã –ø–æ–ª—É—á–∞—é—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
- —Å—É–¥—å–∏: —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É—é—Ç—Å—è –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É, –≤–∏–¥—è—Ç —Å–ø–∏—Å–æ–∫ –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞, –º–æ–≥—É—Ç –≤—ã–±—Ä–∞—Ç—å –º–∞—Ç—á –∏ –≤–≤–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç,
  –º–æ–≥—É—Ç —É–¥–∞–ª—è—Ç—å –º–∞—Ç—á–∏
- —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ –¥–∞—Ç–µ, –ø—Ä–æ—Å–º–æ—Ç—Ä –≤—Å–µ—Ö –º–∞—Ç—á–µ–π (—Å—É–¥—å—è), –ø—Ä–æ—Å–º–æ—Ç—Ä —Å–≤–æ–∏—Ö –º–∞—Ç—á–µ–π (–∫–æ–º–∞–Ω–¥–∏—Ä)
- –∫–Ω–æ–ø–∫–∏ –≤–æ–∑–≤—Ä–∞—Ç–∞ (–ù–∞–∑–∞–¥) –≤ –æ—Å–Ω–æ–≤–Ω—ã—Ö –¥–∏–∞–ª–æ–≥–∞—Ö
- DB: sqlite tournament.db
"""

import asyncio
import logging
import sqlite3
from datetime import date, datetime, timedelta
from typing import Optional, Tuple, List

from aiogram import Bot, Dispatcher, F, types
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import Command
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove,
    InlineKeyboardMarkup, InlineKeyboardButton
)
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State

# ----------------- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ -----------------
API_TOKEN = "8392821328:AAHHINFxwpSZKGRcv0vQXogGc-pnXcAZspI"   # <-- –≤—Å—Ç–∞–≤—å —Å—é–¥–∞ —Ç–æ–∫–µ–Ω
# –ï—Å–ª–∏ —Ö–æ—á–µ—à—å, —á—Ç–æ–±—ã –±–æ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–ª —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ –æ–±—â–∏–π —á–∞—Ç (–≥—Ä—É–ø–ø—É/–∫–∞–Ω–∞–ª), —É–∫–∞–∂–∏ ID:
GROUP_CHAT_ID: Optional[int] = None  # –Ω–∞–ø—Ä–∏–º–µ—Ä -1001234567890 –∏–ª–∏ None

DB_PATH = "tournament.db"

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --------------- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–¥ -------------
def init_db():
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()

    # —Ç–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–∫–æ–º–∞–Ω–¥–∏—Ä—ã –∏ —Å—É–¥—å–∏)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            phone TEXT,
            role TEXT,           -- 'commander' –∏–ª–∏ 'judge'
            team_name TEXT
        )
    """)

    # –∑–∞—è–≤–∫–∏ –∫–æ–º–∞–Ω–¥ (–æ–∂–∏–¥–∞—é—Ç —Å–æ–ø–µ—Ä–Ω–∏–∫–∞)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS match_requests (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team_id INTEGER,
            date TEXT,
            time TEXT
        )
    """)

    # –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–µ –º–∞—Ç—á–∏
    cur.execute("""
        CREATE TABLE IF NOT EXISTS matches (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            team1_id INTEGER,
            team2_id INTEGER,
            date TEXT,
            time TEXT,
            result TEXT,
            judge_id INTEGER
        )
    """)

    conn.commit()
    conn.close()

init_db()

# --------------- FSM ---------------
class RegStates(StatesGroup):
    choosing_role = State()
    waiting_for_contact = State()
    waiting_for_team_name = State()

class ScheduleStates(StatesGroup):
    choosing_date = State()
    choosing_time = State()

class JudgeStates(StatesGroup):
    choosing_match = State()
    entering_result = State()

class DeleteStates(StatesGroup):
    choosing_delete_match = State()

# --------------- –ë–æ—Ç –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä ---------------
bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher(storage=MemoryStorage())

# --------------- –£—Ç–∏–ª–∏—Ç—ã ---------------
def conn_cursor():
    conn = sqlite3.connect(DB_PATH, check_same_thread=False)
    cur = conn.cursor()
    return conn, cur

def dates_next_week_iso() -> List[str]:
    today = date.today()
    return [(today + timedelta(days=i)).isoformat() for i in range(7)]

async def send_safe(user_id: int, text: str):
    try:
        await bot.send_message(user_id, text)
    except Exception as e:
        logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ª–∏—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ %s: %s", user_id, e)

def user_team_name(user_id: int) -> Optional[str]:
    conn, cur = conn_cursor()
    cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return r[0] if r and r[0] else None

def is_commander(user_id: int) -> bool:
    conn, cur = conn_cursor()
    cur.execute("SELECT role FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return bool(r and r[0] == "commander")

def is_judge(user_id: int) -> bool:
    conn, cur = conn_cursor()
    cur.execute("SELECT role FROM users WHERE user_id=?", (user_id,))
    r = cur.fetchone()
    conn.close()
    return bool(r and r[0] == "judge")

def has_match(team_id: int, date_iso: str, time_val: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ —É –∫–æ–º–∞–Ω–¥—ã –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –º–∞—Ç—á –≤ —ç—Ç–æ—Ç —Å–ª–æ—Ç."""
    conn, cur = conn_cursor()
    cur.execute("""
        SELECT 1 FROM matches
        WHERE (team1_id=? OR team2_id=?) AND date=? AND time=?
    """, (team_id, team_id, date_iso, time_val))
    r = cur.fetchone()
    conn.close()
    return r is not None

def remove_request(team_id: int, date_iso: str, time_val: str):
    conn, cur = conn_cursor()
    cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (team_id, date_iso, time_val))
    conn.commit()
    conn.close()

# --------------- –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---------------
role_kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä"), KeyboardButton(text="‚öñÔ∏è –Ø - —Å—É–¥—å—è")]
    ],
    resize_keyboard=True
)

contact_kb = ReplyKeyboardMarkup(
    keyboard=[[KeyboardButton(text="üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º", request_contact=True)]],
    resize_keyboard=True,
    one_time_keyboard=True
)

commander_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É"), KeyboardButton(text="üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")],
        [KeyboardButton(text="üìú –ú–æ–∏ –º–∞—Ç—á–∏"), KeyboardButton(text="üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π")]
    ],
    resize_keyboard=True
)

judge_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìù –í–Ω–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç"), KeyboardButton(text="üìú –í—Å–µ –º–∞—Ç—á–∏")],
        [KeyboardButton(text="üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É"), KeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –º–∞—Ç—á")]
    ],
    resize_keyboard=True
)

back_kb = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="üîô –ù–∞–∑–∞–¥")]], resize_keyboard=True)

# --------------- –•—ç–Ω–¥–ª–µ—Ä—ã ---------------

@dp.message(Command("start"))
async def cmd_start(message: types.Message, state: FSMContext):
    """/start - –ø–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Ä–æ–ª–∏ –∏–ª–∏ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é, –µ—Å–ª–∏ —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω"""
    conn, cur = conn_cursor()
    cur.execute("SELECT role, team_name FROM users WHERE user_id=?", (message.from_user.id,))
    r = cur.fetchone()
    conn.close()

    if r:
        role, team_name = r
        if role == "commander":
            await message.answer("–í—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä.", reply_markup=commander_menu)
        elif role == "judge":
            await message.answer("–í—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è.", reply_markup=judge_menu)
        else:
            await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å:", reply_markup=role_kb)
    else:
        await message.answer("–ü—Ä–∏–≤–µ—Ç! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å:", reply_markup=role_kb)
        await state.set_state(RegStates.choosing_role)

# ---- –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Ä–æ–ª–∏ –∏ —Ç–µ–ª–µ—Ñ–æ–Ω ----
@dp.message(RegStates.choosing_role, F.text.in_(["üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä", "‚öñÔ∏è –Ø - —Å—É–¥—å—è"]))
async def choose_role(message: types.Message, state: FSMContext):
    role = "commander" if message.text == "üõ° –Ø - –∫–æ–º–∞–Ω–¥–∏—Ä" else "judge"
    await state.update_data(chosen_role=role)
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–∫–Ω–æ–ø–∫–∞):", reply_markup=contact_kb)
    await state.set_state(RegStates.waiting_for_contact)

@dp.message(RegStates.waiting_for_contact, F.content_type == types.ContentType.CONTACT)
async def got_contact(message: types.Message, state: FSMContext):
    contact = message.contact
    phone = contact.phone_number if contact else None
    data = await state.get_data()
    role = data.get("chosen_role")
    user_id = message.from_user.id

    conn, cur = conn_cursor()
    cur.execute("INSERT OR REPLACE INTO users (user_id, phone, role, team_name) VALUES (?, ?, ?, COALESCE((SELECT team_name FROM users WHERE user_id=?), NULL))",
                (user_id, phone, role, user_id))
    conn.commit()
    conn.close()

    if role == "commander":
        # –∑–∞–ø—Ä–æ—Å–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã
        await message.answer("–û—Ç–ª–∏—á–Ω–æ ‚Äî —Ç–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã (–æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ):", reply_markup=ReplyKeyboardRemove())
        await state.set_state(RegStates.waiting_for_team_name)
    else:
        # —Å—É–¥—å—è –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω
        await message.answer("‚úÖ –í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—É–¥—å—è.", reply_markup=judge_menu)
        await state.clear()

@dp.message(RegStates.waiting_for_team_name, F.text)
async def got_team_name(message: types.Message, state: FSMContext):
    team_name = message.text.strip()
    if not team_name:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ –µ—â—ë —Ä–∞–∑:")
        return

    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("UPDATE users SET team_name=? WHERE user_id=?", (team_name, user_id))
    conn.commit()
    conn.close()

    await message.answer(f"‚úÖ –ö–æ–º–∞–Ω–¥–∞ <b>{team_name}</b> –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞!", reply_markup=commander_menu)
    await state.clear()

# ---- –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Ç—á–∞: –¥–∞—Ç–∞ -> –≤—Ä–µ–º—è -> —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∑–∞—è–≤–∫–∏/–º–∞—Ç—á–∞ ----
@dp.message(F.text == "üìÖ –ù–∞–∑–Ω–∞—á–∏—Ç—å –∏–≥—Ä—É")
async def start_schedule(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if not is_commander(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ –∫–æ–º–∞–Ω–¥–∏—Ä—ã –º–æ–≥—É—Ç –Ω–∞–∑–Ω–∞—á–∞—Ç—å –∏–≥—Ä—ã. –°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∏—Ä.")
        return
    # –ø—Ä–æ–≤–µ—Ä–∏–º, –µ—Å—Ç—å –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è team_name
    tname = user_team_name(user_id)
    if not tname:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã (—á–µ—Ä–µ–∑ /start).")
        return

    dates = dates_next_week_iso()
    inline = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=d, callback_data=f"slot_date:{d}")] for d in dates
    ])
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π):", reply_markup=inline)
    await state.set_state(ScheduleStates.choosing_date)

@dp.callback_query(F.data.startswith("slot_date:"))
async def on_date_chosen(cb: types.CallbackQuery, state: FSMContext):
    date_iso = cb.data.split(":", 1)[1]
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="19:00", callback_data=f"slot_time:{date_iso}|19:00")],
        [InlineKeyboardButton(text="20:00", callback_data=f"slot_time:{date_iso}|20:00")],
        [InlineKeyboardButton(text="21:00", callback_data=f"slot_time:{date_iso}|21:00")],
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="slot_back")]
    ])
    await cb.message.answer(f"–í—ã–±—Ä–∞–Ω–∞ –¥–∞—Ç–∞ <b>{date_iso}</b>. –í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è:", reply_markup=kb)
    await cb.answer()
    await state.update_data(chosen_date=date_iso)
    await state.set_state(ScheduleStates.choosing_time)

@dp.callback_query(F.data == "slot_back")
async def slot_back(cb: types.CallbackQuery, state: FSMContext):
    # –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –≤—ã–±–æ—Ä—É –¥–∞—Ç—ã
    dates = dates_next_week_iso()
    inline = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=d, callback_data=f"slot_date:{d}")] for d in dates
    ])
    await cb.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π):", reply_markup=inline)
    await cb.answer()
    await state.set_state(ScheduleStates.choosing_date)

@dp.callback_query(F.data.startswith("slot_time:"))
async def on_time_chosen(cb: types.CallbackQuery, state: FSMContext):
    payload = cb.data.split(":", 1)[1]
    date_iso, time_val = payload.split("|", 1)
    user_id = cb.from_user.id

    # –ø—Ä–æ–≤–µ—Ä–∫–∞: —É —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã —É–∂–µ –µ—Å—Ç—å –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –º–∞—Ç—á –≤ —ç—Ç–æ—Ç —Å–ª–æ—Ç?
    # (–∏—Å–∫–ª—é—á–∞–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏–º–µ—Ç—å >1 –º–∞—Ç—á –≤ –æ–¥–Ω–æ –≤—Ä–µ–º—è)
    if has_match(user_id, date_iso, time_val):
        await cb.message.answer("‚ùå –£ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã —É–∂–µ –Ω–∞–∑–Ω–∞—á–µ–Ω –º–∞—Ç—á –≤ —ç—Ç–æ—Ç –¥–µ–Ω—å/–≤—Ä–µ–º—è.")
        await cb.answer()
        await state.clear()
        return

    # –ø—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å—Ç—å –ª–∏ —É–∂–µ –∑–∞—è–≤–∫–∞ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç
    conn, cur = conn_cursor()
    cur.execute("SELECT id FROM match_requests WHERE team_id=? AND date=? AND time=?", (user_id, date_iso, time_val))
    if cur.fetchone():
        conn.close()
        await cb.message.answer("–£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –∑–∞—è–≤–∫–∞ –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç ‚Äî –∂–¥—ë–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.")
        await cb.answer()
        await state.clear()
        return

    # –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞—è–≤–∫—É
    cur.execute("INSERT INTO match_requests (team_id, date, time) VALUES (?, ?, ?)", (user_id, date_iso, time_val))
    conn.commit()

    # –∏—â–µ–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞: –±–µ—Ä—ë–º –∑–∞—è–≤–∫—É –¥—Ä—É–≥–æ–π –∫–æ–º–∞–Ω–¥—ã –Ω–∞ —Ç–æ—Ç –∂–µ —Å–ª–æ—Ç, –Ω–æ –ø—Ä–∏ —ç—Ç–æ–º
    # –∏—Å–∫–ª—é—á–∞–µ–º –∫–æ–º–∞–Ω–¥—ã, —É –∫–æ—Ç–æ—Ä—ã—Ö —É–∂–µ –µ—Å—Ç—å –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –º–∞—Ç—á –≤ —ç—Ç–æ –≤—Ä–µ–º—è (–≤ —Ç–∞–±–ª–∏—Ü–µ matches)
    cur.execute("SELECT id, team_id FROM match_requests WHERE date=? AND time=? AND team_id!=?", (date_iso, time_val, user_id))
    candidates = cur.fetchall()
    opponent_req = None
    for row in candidates:
        req_id, candidate_team_id = row
        # –µ—Å–ª–∏ —É –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ —É–∂–µ –µ—Å—Ç—å match –≤ matches —Ç–∞–±–ª–∏—Ü–µ –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
        if has_match(candidate_team_id, date_iso, time_val):
            continue
        opponent_req = (req_id, candidate_team_id)
        break

    if opponent_req:
        req_id, opp_team_id = opponent_req
        # —Å–æ–∑–¥–∞—ë–º –º–∞—Ç—á: team1 = opp_team_id (—Ç–æ—Ç, –∫—Ç–æ –±—ã–ª —Ä–∞–Ω—å—à–µ), team2 = user_id
        cur.execute("INSERT INTO matches (team1_id, team2_id, date, time) VALUES (?, ?, ?, ?)",
                    (opp_team_id, user_id, date_iso, time_val))
        match_id = cur.lastrowid
        # —É–¥–∞–ª—è–µ–º –∑–∞—è–≤–∫–∏ –æ–±–µ–∏—Ö –∫–æ–º–∞–Ω–¥
        cur.execute("DELETE FROM match_requests WHERE id=?", (req_id,))
        cur.execute("DELETE FROM match_requests WHERE team_id=? AND date=? AND time=?", (user_id, date_iso, time_val))
        conn.commit()

        # —É–≤–µ–¥–æ–º–ª—è–µ–º –æ–±–µ –∫–æ–º–∞–Ω–¥—ã
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (opp_team_id,))
        t1 = cur.fetchone()
        t1_name = t1[0] if t1 and t1[0] else f"ID {opp_team_id}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (user_id,))
        t2 = cur.fetchone()
        t2_name = t2[0] if t2 and t2[0] else f"ID {user_id}"

        text = f"‚öîÔ∏è <b>–ù–∞–∑–Ω–∞—á–µ–Ω –º–∞—Ç—á</b>!\nID {match_id}\nüìÖ {date_iso} ‚è∞ {time_val}\nüèÜ {t1_name} vs {t2_name}"
        # –õ–° –æ–±–µ–∏–º –∫–æ–º–∞–Ω–¥–∞–º (–ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ)
        await send_safe(opp_team_id, text)
        await send_safe(user_id, text)
        # –æ–ø–æ–≤–µ—â–µ–Ω–∏–µ –≤ –æ–±—â–∏–π —á–∞—Ç, –µ—Å–ª–∏ –∑–∞–¥–∞–Ω
        if GROUP_CHAT_ID:
            try:
                await bot.send_message(GROUP_CHAT_ID, text)
            except Exception as e:
                logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ GROUP_CHAT_ID: %s", e)

        await cb.message.answer(f"–ú–∞—Ç—á –Ω–∞–∑–Ω–∞—á–µ–Ω: {t1_name} vs {t2_name} (ID {match_id})")
        await cb.answer()
        conn.close()
        await state.clear()
        return

    # –µ—Å–ª–∏ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –Ω–µ—Ç ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º –∑–∞—è–≤–∫—É –∏ –∂–¥—ë–º
    conn.close()
    await cb.message.answer(f"‚úÖ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –Ω–∞ {date_iso} {time_val}. –û–∂–∏–¥–∞–µ–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.")
    await cb.answer()
    await state.clear()

# ---- –ü—Ä–æ—Å–º–æ—Ç—Ä –∑–∞—è–≤–æ–∫ / —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è / –º–∞—Ç—á–∏ –¥–ª—è –∫–æ–º–∞–Ω–¥–∏—Ä–æ–≤ ----
@dp.message(F.text == "üìñ –ú–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
async def my_requests(message: types.Message):
    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("SELECT date, time FROM match_requests WHERE team_id=?", (user_id,))
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞—è–≤–æ–∫.")
        return
    lines = [f"{d} {t}" for d, t in rows]
    await message.answer("üìÖ –í–∞—à–∏ –∑–∞—è–≤–∫–∏:\n" + "\n".join(lines))

@dp.message(F.text == "üìú –ú–æ–∏ –º–∞—Ç—á–∏")
async def my_matches(message: types.Message):
    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time, result FROM matches WHERE team1_id=? OR team2_id=?", (user_id, user_id))
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–£ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥—ã –ø–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π.")
        return
    lines = []
    for mid, t1, t2, d, tm, res in rows:
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        tn1 = cur.fetchone()[0] if cur.fetchone() is None else cur.fetchone()[0]  # safe fallback
        # The above double fetch is intentionally conservative; fix to simple:
        conn.close()
    # We'll produce with simple fetch logic to avoid double fetch issue:
    conn, cur = conn_cursor()
    text_lines = []
    for mid, t1, t2, d, tm, res in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        n1_row = cur.fetchone()
        n1 = n1_row[0] if n1_row and n1_row[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        n2_row = cur.fetchone()
        n2 = n2_row[0] if n2_row and n2_row[0] else f"ID {t2}"
        text_lines.append(f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2} | {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –∑–∞–¥–∞–Ω'}")
    conn.close()
    await message.answer("üìú –í–∞—à–∏ –º–∞—Ç—á–∏:\n" + "\n".join(text_lines))

@dp.message(F.text == "üìö –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π")
async def my_history(message: types.Message):
    user_id = message.from_user.id
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time, result FROM matches WHERE (team1_id=? OR team2_id=?) AND result IS NOT NULL ORDER BY date DESC, time", (user_id, user_id))
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π –ø—É—Å—Ç–∞.")
        return
    text_lines = []
    for mid, t1, t2, d, tm, res in rows:
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        n1 = cur.fetchone()[0] if cur.fetchone() is None else None  # fix below
        conn.close()
    # Simplify safe retrieval
    conn, cur = conn_cursor()
    text_lines = []
    for mid, t1, t2, d, tm, res in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        name1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        name2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        text_lines.append(f"ID {mid}: {d} {tm} ‚Äî {name1} vs {name2} | {res}")
    conn.close()
    await message.answer("üìö –ò—Å—Ç–æ—Ä–∏—è (—Å—ã–≥—Ä–∞–Ω–Ω—ã–µ –º–∞—Ç—á–∏):\n" + "\n".join(text_lines))

# ---- –°—É–¥—å—è: –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ –º–∞—Ç—á–∏ (–¥–ª—è —Å—É–¥–µ–π) ----
@dp.message(F.text == "üìú –í—Å–µ –º–∞—Ç—á–∏")
async def all_matches(message: types.Message):
    user_id = message.from_user.id
    if not is_judge(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ –¥–ª—è —Å—É–¥–µ–π.")
        return
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time, result FROM matches ORDER BY date, time")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ü–æ–∫–∞ –Ω–µ—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π.")
        return
    text_lines = []
    conn, cur = conn_cursor()
    for mid, t1, t2, d, tm, res in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        name1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        name2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        text_lines.append(f"ID {mid}: {d} {tm} ‚Äî {name1} vs {name2} | {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –∑–∞–¥–∞–Ω'}")
    conn.close()
    await message.answer("üìú –í—Å–µ –º–∞—Ç—á–∏:\n" + "\n".join(text_lines))

# ---- –°—É–¥—å—è: –≤—ã–±—Ä–∞—Ç—å –º–∞—Ç—á –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (inline) ----
@dp.message(F.text == "üìù –í–Ω–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç")
async def judge_choose_match_start(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if not is_judge(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ —Å—É–¥—å—è –º–æ–∂–µ—Ç –≤–Ω–æ—Å–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç.")
        return

    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time FROM matches WHERE result IS NULL ORDER BY date, time")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.")
        return

    inline_buttons = []
    for mid, t1, t2, d, tm in rows:
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        n2 = r2[0] if r2 and r2[0] else f"ID {t2}"
        conn.close()
        inline_buttons.append([InlineKeyboardButton(text=f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2}", callback_data=f"judge_pick:{mid}")])

    kb = InlineKeyboardMarkup(inline_keyboard=inline_buttons)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á –¥–ª—è –≤–≤–æ–¥–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞:", reply_markup=kb)
    await state.set_state(JudgeStates.choosing_match)

@dp.callback_query(JudgeStates.choosing_match, F.data.startswith("judge_pick:"))
async def judge_pick_match(cb: types.CallbackQuery, state: FSMContext):
    mid = int(cb.data.split(":", 1)[1])
    await state.update_data(chosen_match_id=mid)
    await cb.message.answer(f"–í–≤–µ–¥–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –º–∞—Ç—á–∞ ID {mid} –≤ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ (–ø—Ä–∏–º–µ—Ä: 2-1 –∏–ª–∏ Team1 2:1 Team2):")
    await cb.answer()
    await state.set_state(JudgeStates.entering_result)

@dp.message(JudgeStates.entering_result, F.text)
async def judge_save_result(message: types.Message, state: FSMContext):
    data = await state.get_data()
    mid = data.get("chosen_match_id")
    if not mid:
        await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: –º–∞—Ç—á –Ω–µ –≤—ã–±—Ä–∞–Ω. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏—é.")
        await state.clear()
        return
    result_text = message.text.strip()
    conn, cur = conn_cursor()
    cur.execute("UPDATE matches SET result=?, judge_id=? WHERE id=?", (result_text, message.from_user.id, mid))
    conn.commit()

    # —É–≤–µ–¥–æ–º–∏—Ç—å –∫–æ–º–∞–Ω–¥—ã
    cur.execute("SELECT team1_id, team2_id, date, time FROM matches WHERE id=?", (mid,))
    row = cur.fetchone()
    if row:
        team1_id, team2_id, d, tm = row
        # –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –õ–°, –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ
        await send_safe(team1_id, f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ ID {mid}: {result_text} ({d} {tm})")
        if team2_id:
            await send_safe(team2_id, f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ ID {mid}: {result_text} ({d} {tm})")
        # group notify
        if GROUP_CHAT_ID:
            try:
                await bot.send_message(GROUP_CHAT_ID, f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞ ID {mid}: {result_text} ({d} {tm})")
            except Exception as e:
                logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å group notify: %s", e)

    conn.close()
    await message.answer(f"‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –º–∞—Ç—á–∞ ID {mid} —Å–æ—Ö—Ä–∞–Ω—ë–Ω.")
    await state.clear()

# ---- –°—É–¥—å—è: —É–¥–∞–ª–∏—Ç—å –º–∞—Ç—á (inline selection) ----
@dp.message(F.text == "üóë –£–¥–∞–ª–∏—Ç—å –º–∞—Ç—á")
async def judge_delete_match_start(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if not is_judge(user_id):
        await message.answer("–¢–æ–ª—å–∫–æ —Å—É–¥—å—è –º–æ–∂–µ—Ç —É–¥–∞–ª—è—Ç—å –º–∞—Ç—á–∏.")
        return

    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, date, time FROM matches ORDER BY date, time")
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return

    inline_buttons = []
    for mid, t1, t2, d, tm in rows:
        conn, cur = conn_cursor()
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        n2 = r2[0] if r2 and r2[0] else f"ID {t2}" if t2 else "??"
        conn.close()
        inline_buttons.append([InlineKeyboardButton(text=f"ID {mid}: {d} {tm} ‚Äî {n1} vs {n2}", callback_data=f"del_match:{mid}")])

    kb = InlineKeyboardMarkup(inline_keyboard=inline_buttons)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=kb)
    await state.set_state(DeleteStates.choosing_delete_match)

@dp.callback_query(DeleteStates.choosing_delete_match, F.data.startswith("del_match:"))
async def judge_confirm_delete(cb: types.CallbackQuery, state: FSMContext):
    mid = int(cb.data.split(":", 1)[1])
    conn, cur = conn_cursor()
    cur.execute("SELECT team1_id, team2_id, date, time FROM matches WHERE id=?", (mid,))
    row = cur.fetchone()
    if not row:
        await cb.message.answer("–ú–∞—Ç—á –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        conn.close()
        await state.clear()
        await cb.answer()
        return
    t1, t2, d, tm = row
    # —É–¥–∞–ª—è–µ–º
    cur.execute("DELETE FROM matches WHERE id=?", (mid,))
    conn.commit()
    conn.close()

    # —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    await cb.message.answer(f"–ú–∞—Ç—á ID {mid} —É–¥–∞–ª—ë–Ω ‚úÖ")
    await send_safe(t1, f"‚ùå –ú–∞—Ç—á ID {mid} –±—ã–ª —É–¥–∞–ª—ë–Ω —Å—É–¥—å—ë–π ({d} {tm}).")
    if t2:
        await send_safe(t2, f"‚ùå –ú–∞—Ç—á ID {mid} –±—ã–ª —É–¥–∞–ª—ë–Ω —Å—É–¥—å—ë–π ({d} {tm}).")
    if GROUP_CHAT_ID:
        try:
            await bot.send_message(GROUP_CHAT_ID, f"‚ùå –ú–∞—Ç—á ID {mid} –±—ã–ª —É–¥–∞–ª—ë–Ω —Å—É–¥—å—ë–π ({d} {tm}).")
        except Exception:
            pass

    await state.clear()
    await cb.answer()

# ---- –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É (–≤—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –º–æ–≥—É—Ç —Å–º–æ—Ç—Ä–µ—Ç—å) ----
@dp.message(F.text == "üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ –¥–∞—Ç—É")
async def results_date_choose(message: types.Message):
    # –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π –≤—ã–±–æ—Ä–∞ (–º–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å –ø–æ–ª–∏—Ç–∏–∫—É)
    today = date.today()
    days = [(today - timedelta(days=i)).isoformat() for i in range(7)]
    inline = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=d, callback_data=f"res_date:{d}")] for d in days
    ])
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É:", reply_markup=inline)

@dp.callback_query(F.data.startswith("res_date:"))
async def show_results_for_date(cb: types.CallbackQuery):
    d = cb.data.split(":", 1)[1]
    conn, cur = conn_cursor()
    cur.execute("SELECT id, team1_id, team2_id, time, result FROM matches WHERE date=?", (d,))
    rows = cur.fetchall()
    conn.close()
    if not rows:
        await cb.message.answer("–ù–µ—Ç –º–∞—Ç—á–µ–π –∑–∞ —ç—Ç—É –¥–∞—Ç—É.")
        await cb.answer()
        return
    lines = []
    conn, cur = conn_cursor()
    for mid, t1, t2, tm, res in rows:
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t1,))
        r1 = cur.fetchone()
        n1 = r1[0] if r1 and r1[0] else f"ID {t1}"
        cur.execute("SELECT team_name FROM users WHERE user_id=?", (t2,))
        r2 = cur.fetchone()
        n2 = r2[0] if r2 and r2[0] else (f"ID {t2}" if t2 else "??")
        lines.append(f"ID {mid}: {tm} ‚Äî {n1} vs {n2} | {res or '—Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –∑–∞–¥–∞–Ω'}")
    conn.close()
    await cb.message.answer(f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ {d}:\n" + "\n".join(lines))
    await cb.answer()

# --------------- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ "üîô –ù–∞–∑–∞–¥" ---------------
@dp.message(F.text == "üîô –ù–∞–∑–∞–¥")
async def back_to_menu(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if is_commander(user_id):
        await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é –∫–æ–º–∞–Ω–¥–∏—Ä–∞:", reply_markup=commander_menu)
    elif is_judge(user_id):
        await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é —Å—É–¥—å–∏:", reply_markup=judge_menu)
    else:
        await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=role_kb)
    await state.clear()

# --------------- –ó–∞–ø—É—Å–∫ ---------------
async def main():
    logger.info("–£–¥–∞–ª—è–µ–º webhook (–µ—Å–ª–∏ –µ—Å—Ç—å) –∏ –∑–∞–ø—É—Å–∫–∞–µ–º polling")
    try:
        await bot.delete_webhook(drop_pending_updates=True)
    except Exception as e:
        logger.info("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ webhook: %s", e)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
