import asyncio
import sqlite3
from datetime import datetime

from aiogram import Bot, Dispatcher, F, types
from aiogram.enums import ParseMode
from aiogram.filters import CommandStart
from aiogram.types import (
    ReplyKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardRemove
)

# === Настройки ===
TOKEN = "ТОКЕН_ТВОЕГО_БОТА"

bot = Bot(token=TOKEN, parse_mode=ParseMode.HTML)
dp = Dispatcher()

# === База данных ===
conn = sqlite3.connect("squadbot.db")
cursor = conn.cursor()

cursor.execute("""
CREATE TABLE IF NOT EXISTS commanders (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER UNIQUE,
    phone TEXT,
    team_name TEXT
)
""")

cursor.execute("""
CREATE TABLE IF NOT EXISTS judges (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER UNIQUE,
    phone TEXT,
    name TEXT
)
""")

cursor.execute("""
CREATE TABLE IF NOT EXISTS matches (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team1 TEXT,
    team2 TEXT,
    match_time TEXT,
    result TEXT,
    judge_id INTEGER
)
""")

cursor.execute("""
CREATE TABLE IF NOT EXISTS roles (
    user_id INTEGER PRIMARY KEY,
    role TEXT
)
""")

conn.commit()

# === Клавиатуры ===
main_kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="Я - командир")],
        [KeyboardButton(text="Я - судья")]
    ],
    resize_keyboard=True
)

contact_kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="Отправить телефон", request_contact=True)]
    ],
    resize_keyboard=True
)

# === Хэндлеры ===
@dp.message(CommandStart())
async def cmd_start(message: types.Message):
    await message.answer("Добро пожаловать в турнирный бот Squad!\nВыберите роль:", reply_markup=main_kb)


# --- Регистрация командира ---
@dp.message(F.text == "Я - командир")
async def register_commander(message: types.Message):
    cursor.execute("INSERT OR REPLACE INTO roles (user_id, role) VALUES (?, ?)", (message.from_user.id, "commander"))
    conn.commit()
    await message.answer("Пожалуйста, отправьте свой номер телефона:", reply_markup=contact_kb)


# --- Регистрация судьи ---
@dp.message(F.text == "Я - судья")
async def register_judge(message: types.Message):
    cursor.execute("INSERT OR REPLACE INTO roles (user_id, role) VALUES (?, ?)", (message.from_user.id, "judge"))
    conn.commit()
    await message.answer("Пожалуйста, отправьте свой номер телефона:", reply_markup=contact_kb)


# --- Обработка телефона ---
@dp.message(F.contact)
async def process_contact(message: types.Message):
    phone = message.contact.phone_number
    user_id = message.from_user.id

    # Определяем роль
    role_row = cursor.execute("SELECT role FROM roles WHERE user_id = ?", (user_id,)).fetchone()
    if not role_row:
        await message.answer("Сначала выберите роль: командир или судья", reply_markup=main_kb)
        return

    role = role_row[0]

    if role == "commander":
        cursor.execute("INSERT OR REPLACE INTO commanders (user_id, phone, team_name) VALUES (?, ?, ?)",
                       (user_id, phone, None))
        conn.commit()
        await message.answer("Теперь отправьте название вашей команды:", reply_markup=ReplyKeyboardRemove())

    elif role == "judge":
        cursor.execute("INSERT OR REPLACE INTO judges (user_id, phone, name) VALUES (?, ?, ?)",
                       (user_id, phone, message.from_user.full_name))
        conn.commit()
        await message.answer("Вы зарегистрированы как судья!", reply_markup=ReplyKeyboardRemove())


# --- Сохранение названия команды ---
@dp.message(F.text & ~F.via_bot & ~F.contact)
async def save_team_name(message: types.Message):
    user_id = message.from_user.id
    commander = cursor.execute(
        "SELECT * FROM commanders WHERE user_id = ? AND team_name IS NULL", (user_id,)
    ).fetchone()

    if commander:
        cursor.execute("UPDATE commanders SET team_name = ? WHERE user_id = ?", (message.text, user_id))
        conn.commit()
        await message.answer(f"Команда <b>{message.text}</b> зарегистрирована!", reply_markup=ReplyKeyboardRemove())


# --- Судья добавляет результаты ---
@dp.message(F.text == "Добавить результат матча")
async def judge_add_result(message: types.Message):
    matches = cursor.execute("SELECT id, team1, team2, match_time FROM matches WHERE result IS NULL").fetchall()
    if not matches:
        await message.answer("Нет матчей без результатов.")
        return

    reply = "Выберите матч и укажите результат (формат: <id>. Победила команда ...):\n"
    for m in matches:
        reply += f"{m[0]}. {m[1]} vs {m[2]} — {m[3]}\n"
    await message.answer(reply)


@dp.message(F.text.regexp(r"^\d+\..*"))
async def save_result(message: types.Message):
    try:
        match_id, result = message.text.split(".", 1)
        match_id = int(match_id.strip())
        result = result.strip()

        cursor.execute("UPDATE matches SET result = ? WHERE id = ?", (result, match_id))
        conn.commit()

        await message.answer(f"Результат для матча {match_id} сохранён: {result}")
    except Exception:
        await message.answer("Ошибка при сохранении результата. Используйте формат:\n1. Победила команда A")


# --- Просмотр прошедших матчей ---
@dp.message(F.text == "Результаты за сегодня")
async def today_results(message: types.Message):
    today = datetime.now().strftime("%Y-%m-%d")
    matches = cursor.execute(
        "SELECT team1, team2, match_time, result FROM matches WHERE date(match_time) = ?", (today,)
    ).fetchall()

    if not matches:
        await message.answer("Сегодня матчей не было.")
        return

    reply = f"Матчи за {today}:\n"
    for m in matches:
        reply += f"{m[0]} vs {m[1]} — {m[3] or 'ещё не сыгран'}\n"

    await message.answer(reply)


# === Запуск ===
async def main():
    print("✅ Бот запущен...")
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())
